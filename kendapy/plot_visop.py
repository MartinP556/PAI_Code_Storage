#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . P L O T _ V I S O P
#  postprocess VISOP results generated by KENDA experiments
#
#  2017.3 L.Scheck 

from __future__ import absolute_import, division, print_function
# import matplotlib/pylab such that it does not require a X11 connection
import matplotlib
matplotlib.use('Agg') 
import pylab as plt
#from mpl_toolkits.basemap import Basemap, cm
import matplotlib.gridspec as gridspec

import sys, os, argparse
from numpy import *
from kendapy.experiment import Experiment
from kendapy.time14 import Time14, time_range
from kendapy.binplot import binplot
from kendapy.visop_i2o_em import area_settings

#--------------------------------------------------------------------------------
def plot_images( xp, times=[], channel='VIS006', output_path='', file_type='png' ) :

    from visop.plot_reflectances import plot_reflectance

    for t in times :
        refl = {}
        for i in range(-1,int(xp.settings['N_ENS'])+1) :
            fname = xp.visop_filename( t, memidx=i, channel=channel )
            if os.path.exists(fname) :
                pfname = fname.replace('feedback','plots').replace('.npy','')+'.'+file_type
                pdirname = os.path.dirname(pfname)
                if not os.path.exists(pdirname) :
                    print(('creating ', pdirname))
                    os.system('mkdir -p '+pdirname)

                refl[i] = load(fname)
                if i == 0 : obs = refl+0
                plot_reflectance( refl[i], channel, pfname, vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=False, contours=0 )

               

#--------------------------------------------------------------------------------
def plot_histograms( xp, times=[], channel='VIS006', output_path='', file_type='png' ) :

    from visop.sysdif import define_mask
    mask = define_mask()
    valid = where(mask!=True)
    bins = linspace(0,1.2,121)
    
    for t in times :

        fname = xp.visop_filename( t, memidx=-1, channel=channel )
        if os.path.exists(fname) :
            pfname = fname.replace('feedback','plots').replace('.npy','')+'_histograms.'+file_type
            pdirname = os.path.dirname(pfname)
            if not os.path.exists(pdirname) :
                print(('creating ', pdirname))
                os.system('mkdir -p '+pdirname)

            plt.figure(1,figsize=(8,5))
            plt.clf()

            for i in arange(-1,int(xp.settings['N_ENS'])+1)[::-1] :
                fname = xp.visop_filename( t, memidx=i, channel=channel )

                if os.path.exists(fname) :
                    refl = load(fname)
                    hist, edges = histogram( refl[~mask], bins=bins )
                    
                    color='#999999'
                    lw=0.3
                    if i == -1 :
                        color='k'
                        lw = 1
                    binplot( edges, hist, color=color, linewidth=lw )

            print(('saving %s ...' % pfname))
            plt.savefig(pfname)

#def get_visop_metrics( self, times=None, channel='VIS006' ) :




#-------------------------------------------------------------------------------
if __name__ == "__main__": # ---------------------------------------------------
#-------------------------------------------------------------------------------

    parser = argparse.ArgumentParser(description='Generate VISOP plots for KENDA experiment')

    parser.add_argument( '-E', '--evolution',   dest='error_evolution',   help='generate error evolution plots', action='store_true' )
    parser.add_argument(       '--no-ekf',      dest='no_ekf',            help='do not use ekf data in error evolution plots', action='store_true' )

    parser.add_argument( '-c', '--clc',         dest='clc_evolution',  help='plot clc evolution', action='store_true' )
    parser.add_argument( '-n', '--not-all-members',  dest='not_all_members',  help='do not generate plots for each of the members', action='store_true' )
    parser.add_argument( '-m', '--multiscale',   dest='multiscale',        help='multiscale metrics plots', action='store_true' )
    #parser.add_argument(       '--scales',      dest='scales', default='1,2,3,4,5,6,7'

#    parser.add_argument( '-C', '--compare',     dest='compare',     help='generate comparison plots with data from all specified experiments',
#                                                                    action='store_true' )

    parser.add_argument( '-l', '--lfcst',       dest='lfcst',      help='take also long forecasts (not only cycling results) into account',   action='store_true' )

    parser.add_argument( '-T', '--transform',   dest='transform',  help='transform images to observations',  action='store_true' )
    parser.add_argument(       '--i2o-settings',   dest='i2o_settings',  help='visop_i2o settings string [default: the one from the experiment settings]',  default='experiment' )

    parser.add_argument( '-I', '--images',      dest='images',     help='plot satellite images',       action='store_true' )
    parser.add_argument( '-H', '--histograms',  dest='histograms', help='plot reflectance histograms', action='store_true' )
    parser.add_argument(       '--channel',     dest='channel',    help='channel[s] (comma-separated list, deafult=VIS006)', default='VIS006' )

 #   parser.add_argument( '-V', '--variables',   dest='variables',   help='comma-separated list of variables  to be considered (default: all)', default='' )
 #   parser.add_argument( '-O', '--obs-types',   dest='obs_types',   help='comma-separated list of obs. types to be considered (default: all)', default='' )
    parser.add_argument( '-s', '--start-time',  dest='start_time',  help='start time',    default='' )
    parser.add_argument( '-e', '--end-time',    dest='end_time',    help='end time',      default='' )
    parser.add_argument( '-d', '--delta-time',  dest='delta_time',  help='time interval', default='' )

    parser.add_argument(       '--dwd2lmu',     dest='dwd2lmu',     help='convert settings',  action='store_true' )

    parser.add_argument( '-p', '--path',        dest='output_path', help='path to the directory in which the plots will be saved', default='auto' )
    parser.add_argument( '-f', '--filetype',    dest='file_type',   help='file type [ png (default) | pdf | eps | svg ...]', default='png' )
    parser.add_argument( '-v', '--verbose',     dest='verbose',     help='be more verbose',   action='store_true' )    

    parser.add_argument( 'logfile', metavar='logfile', help='log file name', nargs='*' )
    args = parser.parse_args()

    # process all log files

    xps = {}
    for logfile in args.logfile :

        print()
        print(("processing file %s ..." % logfile))

        xp = Experiment(logfile, dwd2lmu=args.dwd2lmu)
        xps[logfile] = xp
        print(('experiment %s : %s #members, first fcst start time %s, last analysis time %s' % ( \
               xp.settings['exp'], xp.settings['N_ENS'], xp.fcst_start_times[0], xp.veri_times[-1] )))

        titlestr = "%s T_win=%4.2fh e_o=%s h_loc=%s superobb=%s " % (
                    xp.settings['EXPID'],
                    float(xp.settings['ASSINT'])/3600.0,
                    xp.settings['VISOP_ERROR'],
                    xp.settings['VISOP_HLOC'],
                    xp.settings['VISOP_SUPEROBB'])

        # set some default values

        if args.output_path != '' :
            if args.output_path != 'auto' :
                output_path = args.output_path+'/'
            else :
                output_path = xp.settings['PLOT_DIR']+'/visop/'
                if not os.path.exists(output_path) :
                    os.system('mkdir '+output_path)
        else :
            output_path = ''

        # determine time range

        if args.start_time != '' :
            start_time = args.start_time
        else :
            #start_time = xp.veri_times[0]
            start_time = xp.veri_times[0]
            start_time = start_time[:8] + ("%02d" % int(xp.settings['VISOP_START_HOUR'])) + start_time[10:]
            print(('selecting start time = ', start_time))

        if args.end_time != '' :
            end_time = args.end_time
        else :
            end_time = xp.fcst_start_times[-1]
            end_time = end_time[:8] + ("%02d" % (int(xp.settings['VISOP_STOP_HOUR'])-1)) + end_time[10:]
            print(('selecting end time = ', end_time))

        if args.delta_time != '' :
            delta_time = args.delta_time
        else :
            delta_time = xp.settings['ASSINT']
        times = time_range( start_time, end_time, delta_time  )

        print(('fcst start times: ', times))
        fcsttimes = xp.visop_fcsttimes()


        #settings_list = [xp.settings['VISOP_I2O_SETTINGS']]
        #settings_list.append('LATLON:COSMO-DE-NOALPS')
        scales = [1,2,4,8,16,32,64]
            #multiscale_settings = {}
            #for s in [1,2,4,8,16] :
            #    multiscale_settings[s] = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                #settings_list.append(multiscale_settings[s])

        # loop over channels and times, read data and generate plots
        for channel in args.channel.split(',') :

            stats = {}
            clc   = {}
            mstat = {}
            for t in times :
                stats[t] = {}
                clc[t]   = {}
                mstat[t] = {}
                for fcsttime in fcsttimes :
                    fname0 = xp.visop_filename( t, fcsttime=fcsttime, memidx=0, channel=channel )
                    if not os.path.exists(fname0) :
                        print(('does not exist : ', fname0))
                        continue
                    base_pfname = fname0.split('/')[-1].replace('.000.npy','')
                    
                    print(('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime)))
                    vens = xp.get_visop( t, fcsttime=fcsttime, channel=args.channel )
                    #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                    if args.error_evolution :
                        stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=args.i2o_settings),
                                               'spread': vens.i2o('spread', settings=args.i2o_settings),
                                               'rmse':   vens.i2o('rmse',   settings=args.i2o_settings) }
                        print(('stats : ', stats[t][fcsttime]))

                    if args.multiscale :
                        mstat[t][fcsttime] = {}
                        for s in scales :
                            settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                            mstat[t][fcsttime][s] = { 'settings':settings,
                                                      'bias':   vens.i2o('bias',   settings=settings),
                                                      'spread': vens.i2o('spread', settings=settings),
                                                      'rmse':   vens.i2o('rmse',   settings=settings) }
                            if True : # do it for all members
                                for m in range(1,xp.n_ens+1) :
                                    mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                    mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                            #print ('scale %02d : '%s), mstat[t][fcsttime][s]

                    if args.clc_evolution :
                        # extract area information, get rid of all transformations (superobbing etc.)
                        area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                        clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                             'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                             'det30':    vens.i2o('clc30_det',    settings=area),
                                             'obs60':    vens.i2o('clc60_obs',    settings=area),
                                             'ensmean60':vens.i2o('clc60_ensmean',settings=area),
                                             'det60':    vens.i2o('clc60_det',    settings=area) }
                    if args.images :
                        from visop.plot_reflectances import plot_reflectance
                        grid = True
                        if args.not_all_members :
                            ilast = 1
                            print('plotting images for obs / det / mean ', end=' ')
                        else :
                            ilast = int(xp.settings['N_ENS'])+1
                            print('plotting images for obs / det / mean and all members ', end=' ')
                        print(('in %s ...' % output_path))

                        # reflectance distribtion from observation, deterministic run and members
                        iname = 'refl'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        for i in range(-1,ilast) :
                            fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=i, channel=channel )
                            #print 'base filename for member ', i, ' images : ', fname
                            pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','')+'.'+args.file_type
                            if i == -1 :
                                ptitle = "obs"
                            elif i == 0 :
                                ptitle = "det"
                                pfname = pfname.replace('.000.','.det.')
                            else :
                                ptitle="mem. %d"
                            ptitle += ' '+channel+' '+t
                            plot_reflectance( vens[i], ptitle, pfname, vmin=0.0, vmax=1.0,
                                              infos=False, notext=False, grid=grid, contours=0 )

                        # reflectance errors for det, ensemble members...
                        iname = 'refl_error'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        for i in range(0,ilast) :
                            fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=i, channel=channel )
                            #print iname +': base filename for member ', i, ' images : ', fname
                            pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname)+'.'+args.file_type
                            if i == -1 :
                                ptitle = "obs"
                            elif i == 0 :
                                ptitle = "det"
                                pfname = pfname.replace('.000_','.det_')
                            else :
                                ptitle="mem. %d"
                            ptitle += ' '+channel+' '+t
                            if i==0 :
                                obs = vens[-1] + 0.0
                                obs[ where(vens[i]<1e-6) ] = 0
                            plot_reflectance( vens[i]-obs, ptitle, pfname, vmin=-1.0, vmax=1.0,
                                              infos=True, notext=False, grid=grid, contours=0,
                                              cfield=vens[-1], cfield_alpha=0.05, thres=0.3 )
                        # ...and ensemble mean
                        fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel )
                        pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname).replace('.001_','.mean_')+'.'+args.file_type
                        ptitle = 'mean '+channel+' '+t
                        plot_reflectance( vens.mean2d()-obs, ptitle, pfname, vmin=-1.0, vmax=1.0,
                                          infos=True, notext=False, grid=grid, contours=0,
                                          cfield=vens[-1], cfield_alpha=0.05, thres=0.3 )

                        # spaghetti plots
                        iname = 'spag03'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
                        ptitle = 'spaghetti R=0.3 '+channel+' '+t
                        plot_reflectance( vens[-1]*0+1, ptitle, pfname, vmin=0.0, vmax=1.0,
                                          infos=False, notext=False, grid=grid, contours=0, spag=vens, thres=0.3 )
                        iname = 'spag05'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
                        ptitle = 'spaghetti R=0.5 '+channel+' '+t
                        plot_reflectance( vens[-1]*0+1, ptitle, pfname, vmin=0.0, vmax=1.0,
                                          infos=False, notext=False, grid=grid, contours=0, spag=vens, thres=0.5 )

                        # probability of cloudiness
                        iname = 'probex03'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
                        ptitle = 'P(R>0.3) '+channel+' '+t
                        plot_reflectance( vens.probex(thres=0.3), ptitle, pfname, vmin=0.0, vmax=1.0,
                                          infos=False, notext=False, grid=grid, contours=0,
                                          cfield=vens[-1], cfield_alpha=0.2, thres=0.3 )
                        iname = 'probex05'
                        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
                        pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
                        ptitle = 'P(R>0.5) '+channel+' '+t
                        plot_reflectance( vens.probex(thres=0.5), ptitle, pfname, vmin=0.0, vmax=1.0,
                                          infos=False, notext=False, grid=grid, contours=0,
                                          cfield=vens[-1], cfield_alpha=0.2, thres=0.5 )

                        if False :
                            # mean, spread and bias plots

                            pfname = base_pfname+'.mean.'+args.file_type
                            ptitle = 'mean '+channel+' '+t
                            plot_reflectance( vens.mean2d(), ptitle, pfname, vmin=0.0, vmax=1.0,
                                              infos=False, notext=False, grid=grid, contours=0,
                                              cfield=vens.eval_region(binary=True)*1.0, cfield_alpha=0.0, thres=0.5 )

                            pfname = base_pfname+'.spread.'+args.file_type
                            ptitle = 'spread '+channel+' '+t
                            plot_reflectance( vens.spread2d(), ptitle, pfname, vmin=0, vmax=0.5,
                                              infos=False, notext=False, grid=grid, contours=0,
                                              cfield=vens.eval_region(binary=True)*1.0, cfield_alpha=0.0, thres=0.5 )

                            pfname = base_pfname+'.bias.'+args.file_type
                            ptitle = 'bias '+channel+' '+t
                            plot_reflectance( vens.bias2d(), ptitle, pfname, vmin=-0.5, vmax=0.5,
                                              infos=False, notext=False, grid=grid, contours=0,
                                              cfield=vens.eval_region(binary=True)*1.0, cfield_alpha=0.0, thres=0.5 )

                    if False :
                        # contingency table based scores
                        cts = vens.contingency_scores( thres=0.5 )
                        for s in list(cts.keys()) :
                            pfname = base_pfname+'.'+s+'.'+args.file_type
                            ptitle = s+' '+channel+' '+t
                            print((s+' min/mean/max ', cts[s].min(), cts[s].mean(), cts[s].max()))
                            plot_reflectance( cts[s], ptitle, pfname, vmin=None, vmax=None,
                                              infos=False, notext=False, grid=grid, contours=0 )
            # end of time loop .....................................................................

            # gather data from long forecasts .....................................................
            if args.lfcst :
                print()
                print('Gathering data from long forecasts...')
                lfcst_stats = {}
                lfcst_clc   = {}
                lfcst_mstat = {}
                for t in times :
                    print('time ', t, end=' ')
                    if t in xp.lfcst_start_times :
                        print('is relevant')
                        lfcst_stats[t] = {}
                        lfcst_clc[t]   = {}
                        lfcst_mstat[t] = {}
                        for fcsttime in xp.lfcst_visop_output_times :
                            fname1 = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=True )
                            if not os.path.exists(fname1) :
                                print(('does not exist : ', fname1))
                                continue
                            base_pfname = fname1.split('/')[-1].replace('.001.npy','')

                            print(('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime)))
                            vens = xp.get_visop( t, fcsttime=fcsttime, channel=args.channel, lfcst=True )
                            #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                            if args.error_evolution :
                                lfcst_stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=args.i2o_settings),
                                                             'spread': vens.i2o('spread', settings=args.i2o_settings),
                                                             'rmse':   vens.i2o('rmse',   settings=args.i2o_settings) }
                                print(('stats : ', lfcst_stats[t][fcsttime]))

                            if args.multiscale :
                                lfcst_mstat[t][fcsttime] = {}
                                for s in scales :
                                    settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                                    lfcst_mstat[t][fcsttime][s] = { 'settings':settings,
                                                              'bias':   vens.i2o('bias',   settings=settings),
                                                              'spread': vens.i2o('spread', settings=settings),
                                                              'rmse':   vens.i2o('rmse',   settings=settings) }
                                    if True : # do it for all members
                                        for m in range(1,xp.n_ens+1) :
                                            lfcst_mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                            lfcst_mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                                    #print ('scale %02d : '%s), mstat[t][fcsttime][s]

                            if args.clc_evolution :
                                # extract area information, get rid of all transformations (superobbing etc.)
                                area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                                lfcst_clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                                           'det30':    vens.i2o('clc30_001',    settings=area),
                                                           'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                                           'obs60':    vens.i2o('clc60_obs',    settings=area),
                                                           'det60':    vens.i2o('clc60_001',    settings=area),
                                                           'ensmean60':vens.i2o('clc60_ensmean',settings=area) }
                                print(('>>> lfcst_clc ', lfcst_clc[t][fcsttime]))

            # end of long forecasts .....................................................................


            # # # # # # # # # # # # # # # # # # # # # # # PLOTS # # # # # # # # # # # # # # # # # # # # # # # # # #

            if args.multiscale :
                import colorsys

                # evolution of rmse and drmse/dt of the ensemble mean for all scales
                plt.figure(1,figsize=(10,5))
                plt.clf()
                plt.figure(2,figsize=(10,5))
                plt.clf()

                hmin = Time14(times[0]).dayhour()
                h = hmin
                add_label=True
                for i, t in enumerate(times) :
                    for iscl, s in enumerate(scales) :
                        hue = float(iscl)/len(scales)
                        col = colorsys.hls_to_rgb( hue, 0.6-0.2*exp(-((hue-0.35)/0.1)**2), 0.7 )
                        km = s*6

                        plt.figure(1)
                        if args.lfcst :
                            if t in lfcst_mstat :
                                lfcst_t_min = sorted(lfcst_mstat[t].keys())
                                lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                                plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse'] for f in lfcst_t_min ], color='#cccccc', linewidth=3 )
                                #plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse'] for f in lfcst_t_min ], '--', color=col )

                        plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ],
                                  color=col, label='%dkm'%km if add_label else None, linewidth=2 )


                        plt.figure(2)
                        rmses = [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ]
                        drmse = rmses[-1]-rmses[-2]
                        dt    = (fcsttimes[-1]-fcsttimes[-2])/60.0
                        plt.plot( (h+fcsttimes[-2]/60.0,h+fcsttimes[-1]/60.0), [drmse/dt,drmse/dt],
                                  color=col, label='%dkm'%km if add_label else None, linewidth=2 )

                    add_label=False
                    h += float(xp.settings['ASSINT'])/3600.0
                hmax = h

                plt.figure(1)
                plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                plt.ylim((0,0.22))
                plt.legend(loc='upper right', frameon=False)
                plt.xlabel('t [h UTC]')
                plt.ylabel('rmse')
                plt.title(titlestr)
                plt.grid()
                plt.savefig('multiscale_rmse_evo_'+channel+'.png')

                plt.figure(2)
                plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                plt.ylim((-0.05,0.1))
                plt.legend(loc='upper right', frameon=False)
                plt.xlabel('t [h UTC]')
                plt.ylabel('drmse/dt')
                plt.title(titlestr)
                plt.grid()
                plt.savefig('multiscale_drmse_dt_evo_'+channel+'.png')

                # rmse evolution of all ensemble member (indiv. plot for each scale)
                plt.figure(1,figsize=(10,5))
                for iscl, s in enumerate(scales) :
                    km = s*6
                    plt.clf()
                    h = hmin
                    add_label=True
                    for i, t in enumerate(times) :
                        plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['spread'] for f in sorted(mstat[t].keys()) ],
                                  '--', color='#999999', label='spread' if add_label else None, linewidth=2 )

                        for m in range(1,xp.n_ens+1) :
                            plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['rmse_mem%03d'%m] for f in sorted(mstat[t].keys()) ],
                                      color='#000000', alpha=0.2, linewidth=1,
                                      label='rmse members' if (add_label and m==1) else None )

                        if args.lfcst :
                            if t in lfcst_mstat :
                                lfcst_t_min = sorted(lfcst_mstat[t].keys())
                                lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                                for m in range(1,xp.n_ens+1) :
                                    plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse_mem%03d'%m] for f in lfcst_t_min ], color='#0066cc', alpha=0.2 )

                        plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ],
                                  color='r', label='rmse mean' if add_label else None, linewidth=2 )
                        add_label=False
                        h += float(xp.settings['ASSINT'])/3600.0

                    plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                    plt.ylim((0,0.3))
                    plt.legend(loc='upper right', frameon=False)
                    plt.xlabel('t [h UTC]')
                    plt.ylabel('rmse')
                    plt.title(titlestr + (" scale %dkm"%km))
                    plt.grid()
                    plt.savefig('multiscale_rmse_s%02d_evo_%s.png' % (s,channel))

                for iscl, s in enumerate([scales[0]]) : # bias is scale-independent...
                    km = s*6
                    plt.clf()
                    h = hmin
                    add_label=True
                    for i, t in enumerate(times) :
                        for m in range(1,xp.n_ens+1) :
                            plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['bias_mem%03d'%m] for f in sorted(mstat[t].keys()) ],
                                      color='#000000', alpha=0.2, linewidth=1 )
                        plt.plot( h+fcsttimes/60.0, [ mstat[t][f][s]['bias'] for f in sorted(mstat[t].keys()) ],
                                  color='k', label='%dkm'%km if add_label else None, linewidth=2 )
                        add_label=False
                        h += float(xp.settings['ASSINT'])/3600.0

                    plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                    #plt.ylim((0,0.22))
                    plt.legend(loc='upper right', frameon=False)
                    plt.xlabel('t [h UTC]')
                    plt.ylabel('bias')
                    plt.title(titlestr)
                    plt.grid()
                    plt.savefig('multiscale_bias_s%02d_evo_%s.png' % (s,channel))



            if args.clc_evolution :
                plt.figure(1,figsize=(10,5))
                plt.clf()
                hmin = Time14(times[0]).dayhour()
                h = hmin
                add_label=True
                for i, t in enumerate(times) :
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['ensmean30'] for f in sorted(clc[t].keys()) ], 'k',               label='ensmean' if add_label else None  )
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['det30']     for f in sorted(clc[t].keys()) ], color='#999999',   label='det'     if add_label else None  )
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['obs30']     for f in sorted(clc[t].keys()) ], 'k',  linewidth=2, label='obs'     if add_label else None )
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['ensmean60'] for f in sorted(clc[t].keys()) ], 'k' )
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['det60']     for f in sorted(clc[t].keys()) ], color='#999999' )
                    plt.plot( h+fcsttimes/60.0, [ clc[t][f]['obs60']     for f in sorted(clc[t].keys()) ], 'k',  linewidth=2 )

                    if args.lfcst :
                        if t in lfcst_clc :
                            lfcst_t_min = sorted(lfcst_clc[t].keys())
                            lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                            plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['ensmean30'] for f in lfcst_t_min ], ':', color='#990099' )
                            plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['ensmean60'] for f in lfcst_t_min ], ':', color='#cc00cc' )
                            plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['det30'] for f in lfcst_t_min ], color='#990099' )
                            plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['det60'] for f in lfcst_t_min ], color='#cc00cc' )

                    add_label=False
                    h += float(xp.settings['ASSINT'])/3600.0
                hmax = h
                plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                plt.ylim((0,1))
                plt.legend(loc='upper right',title='domain cloud cover', frameon=False)
                plt.xlabel('t [h UTC]')
                plt.ylabel('cloud dover')
                plt.title(titlestr)
                plt.savefig('clc_evo_'+channel+'.png')

            if args.error_evolution :

                cycavg = False # plot values averaged over cycles?
                colbias = '#ee9900'
                colspread = '#00ee99' #'#999999'

                # get data from ekfRAD files
                ekfevo = xp.compute_error_evolution( times, obs_types=['RAD'], variables=['REFL'] )['RAD']['REFL']
                #        {'RAD': {'REFL': {'20160605100000': {'fgmean': {'bias': -0.0030769857, 'rmse': 0.08585836}, 'fgspread': {'mean': 0.10906658}...

                plt.figure(1,figsize=(10,5))
                plt.clf()
                plt.figure(2,figsize=(10,5))
                plt.clf()

                hmin = Time14(times[0]).dayhour()
                h = hmin
                add_label=True
                for i, t in enumerate(times) :

                    plt.figure(1)

                    if args.lfcst :
                        if t in lfcst_stats :
                            print((lfcst_stats[t]))
                            lfcst_t_min = sorted(lfcst_stats[t].keys())
                            lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                            print(lfcst_t_hour)
                            plt.plot( lfcst_t_hour, [ lfcst_stats[t][f]['rmse'] for f in lfcst_t_min ], '-', color='#ee6699', linewidth=3 )

                    #print 'TIME', i, t
                    #print 'XXX', h+fcsttimes/60.0
                    #print 'YYY', [ stats[t][f]['rmse']   for f in sorted(stats[t].keys()) ]

                    plt.plot( h+fcsttimes/60.0, [ stats[t][f]['rmse']   for f in sorted(stats[t].keys()) ], '.-k',  label='RMSE'   if add_label else None  )
                    plt.plot( h+fcsttimes/60.0, [ stats[t][f]['spread'] for f in sorted(stats[t].keys()) ], '--', color='#999999', label='spread' if add_label else None  )
                    plt.plot( h+fcsttimes/60.0, [ stats[t][f]['bias']   for f in sorted(stats[t].keys()) ], '.-', color='#999999', label='bias'   if add_label else None  )

                    if not args.no_ekf :
                        if cycavg :
                            fgmean = sqrt((array([ stats[t][f]['rmse'] for f in sorted(stats[t].keys())[1:] ])**2).mean())
                            plt.plot( (h+fcsttimes[1]/60.0,h+fcsttimes[-1]/60.0), (fgmean,fgmean), 'r' )

                        # EKF values: correspond to mean values in the interval ]t,t+ASSINT]
                        if i < len(times)-1 and times[i+1] in ekfevo :
                            if cycavg :
                                # EKF values averaged over assimilation window
                                plt.scatter( h+fcsttimes[1:].mean()/60.0, ekfevo[times[i+1]]['fgmean']['rmse'], marker='x', color='r' )
                                plt.scatter( h+fcsttimes[1:].mean()/60.0, ekfevo[times[i+1]]['anamean']['rmse'], marker='o', color='r' )
                                plt.plot( (h+fcsttimes[1]/60.0,h+fcsttimes[-1]/60.0), (ekfevo[times[i+1]]['anamean']['rmse'],ekfevo[times[i+1]]['anamean']['rmse']), color='r' )

                            #plt.scatter( h+fcsttimes[1:].mean()/60.0, ekfevo[times[i+1]]['fgens']['spread'], marker='x', color=colspread )
                            #plt.scatter( h+fcsttimes[1:].mean()/60.0, ekfevo[times[i+1]]['anaens']['spread'], marker='o', color=colspread )


                            # EKF values at analysis times
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['fgmean']['rmse_last'], marker='x', color='b' )
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['anamean']['rmse_last'], marker='o', color='b' )
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['fgmean']['bias_last'], marker='x', color=colbias )
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['anamean']['bias_last'], marker='o', color=colbias )

                            #plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['fgspread']['mean_last'], marker='.', color=colspread ) # same as ['fgens']['spread_last']
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['fgens']['spread_last'], marker='x', color=colspread )
                            plt.scatter( h+fcsttimes[-1]/60.0, ekfevo[times[i+1]]['anaens']['spread_last'], marker='o', color=colspread )

                    plt.figure(2)
                    if i < len(times)-1 and times[i+1] in ekfevo :
                        fg_rmse      = ekfevo[times[i+1]]['fgmean']['rmse_last']
                        ana_rmse_ekf = ekfevo[times[i+1]]['anamean']['rmse_last']
                        ana_rmse     = stats[times[i+1]][ sorted(stats[times[i+1]].keys())[0] ]['rmse']

                        fg_bias      = ekfevo[times[i+1]]['fgmean']['bias_last']
                        ana_bias_ekf = ekfevo[times[i+1]]['anamean']['bias_last']
                        ana_bias     = stats[times[i+1]][ sorted(stats[times[i+1]].keys())[0] ]['bias']

                        t_hours      = h+fcsttimes[-1]/60.0
                        dt = 0.1
                        plt.plot( (t_hours+dt,t_hours+dt), (ana_rmse_ekf,ana_rmse), 'r', linewidth=3, label='RMSE' if add_label else None )
                        plt.plot( (t_hours-dt,t_hours-dt), (ana_bias_ekf,ana_bias), 'b', linewidth=3, label='bias' if add_label else None )
                        plt.scatter( (t_hours+dt,t_hours-dt), (ana_rmse_ekf,ana_bias_ekf), zorder=3, marker='o', color='k', label='linear' if add_label else None )
                        plt.scatter( (t_hours+dt,t_hours-dt), (ana_rmse,ana_bias),         zorder=3, marker='x', color='k', label='non-linear' if add_label else None )

                    add_label=False
                    h += float(xp.settings['ASSINT'])/3600.0
                hmax = h
                hdur = hmax-hmin
                pltrng = (hmin-0.05*hdur,hmax+0.05*hdur)

                plt.figure(1)
                plt.plot( pltrng, (0,0), '-.k', linewidth=0.3 )
                plt.ylim((-0.05,0.25))
                plt.xlim(pltrng)
                plt.xlabel('t [h] UTC')
                plt.ylabel('reflectance bias / spread / rmse')
                plt.legend(frameon=False)
                plt.title(titlestr)
                plt.grid()
                plt.savefig('error_evo_'+('lfcst_' if args.lfcst else '')+('noekf_' if args.no_ekf else '')+channel+'_i2o-'+args.i2o_settings+'.png')

                plt.figure(2)
                plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
                plt.ylim((-0.05,0.25))
                plt.xlabel('t [h] UTC')
                plt.ylabel('nonlinear vs. linear reflectance bias / rmse')
                plt.legend(frameon=False)
                plt.title(titlestr)
                plt.grid()
                plt.savefig('nonlin_evo_'+channel+'_i2o-'+args.i2o_settings+'.png')


        # end of channel loop ......................................................................
    # end of logfile loop ..........................................................................

