#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . V I S O P_ E N S E M B L E
#  represents VISOP ensembles generated by KENDA experiments
#
#  2017.4 L.Scheck 

from __future__ import absolute_import, division, print_function
import sys, os, argparse
from numpy      import *
from scipy.interpolate import interp2d

from kendapy.experiment import Experiment
from kendapy.time14     import Time14, time_range
from kendapy.visop_i2o_em  import transform_variables
from kendapy.score_brier import brier_score
from kendapy.score_fss import fss_ens_dict, fss_random_target

class VisopEnsemble(object):
    """class representing the VISOP satellite image ensemble generated in a KENDA experiment for a specific time"""

    def __init__( self, xp, starttime, fcsttime=-1, channel='VIS006', lfcst=False, verbose=False, preload=False,
                  addvars=None ) :
        """Initialize object using information from Experiment object"""

        if verbose : print(('VisopEnsemble constructor : time = %s + %dmin ' % ( starttime, fcsttime )))

        self.xp = xp
        self.n_ens = int(self.xp.settings['N_ENS'])
        self.starttime = starttime
        self.fcsttime  = fcsttime   # forcast time in minutes (-1 = last available time = next analysis time)
        self.channel = channel
        self.lfcst = lfcst          # False -> cycling, True -> long forecast
        self.verbose = verbose
        self.reflectance = {}
        self.variables = {}
        self.lat = None
        self.lon = None
        self.statistics = {}
        self.i2o_data = {}
        self.addvars = addvars
        if preload :
            self.load_all_reflectances( det = False if lfcst else True )
            self.load_coordinates()

    def __getitem__( self, index ):
        """
        The [] operator returns the member reflectance field (-1=obs, 0=det).
        """

        if not index in list(self.reflectance.keys()) :
            self.load_reflectance(index)

        return self.reflectance[index]
            
    def load_reflectance( self, index ) :

        if not index in list(self.reflectance.keys()) :
            fname = self.xp.visop_filename( self.starttime, fcsttime=self.fcsttime, memidx=index, channel=self.channel, lfcst=self.lfcst )
            if self.verbose : print('VisopEnsemble: reading {}...'.format(fname))
            try :
                self.reflectance[index] = load(fname)
            except :
                print(('VisopEnsemble: member %d (%s) is missing...' % (index,fname)))

    def load_all_reflectances( self, obs=True, det=None ) :

        if det is None :
            det = False if self.lfcst else True

        for i in range(-1,int(self.xp.settings['N_ENS'])+1) :
            if i == -1 and not obs : continue
            if i ==  0 and not det : continue
            self.load_reflectance(i)

    def load_variable( self, vname, index ) :

        #print 'TRYING TO LOAD  ', vname, index

        if not vname in self.variables :
            if self.verbose : print('initializing new variable %s...'%vname)
            self.variables[vname] = {}
        #    raise IOError('unknown variable')

        if not index in list(self.variables[vname].keys()) :
            fname = self.xp.visop_filename( self.starttime, fcsttime=self.fcsttime, memidx=index, channel=self.channel,
                                            lfcst=self.lfcst ).replace('refl_visop',vname)
            try :
                self.variables[vname][index] = nan_to_num( load(fname) )
                # LS 2018/04/17: NaN-producing error should be gone by now...
            except :
                print('VisopEnsemble: %s for member %d (%s) is missing...' % (vname,index,fname))

    def load_all_variable( self, vname, det=False ) :

        #print 'TRYING TO LOAD ALL ',vname

        #if not vname in self.variables :
        #    raise IOError('unknown variable')

        for i in range(int(self.xp.settings['N_ENS'])+1) :
            if i ==  0 and not det : continue
            self.load_variable(vname,i)

    def get_ensemble_variable( self, vname ) :

        #print 'AVAILABLE VARIABLES ', self.variables.keys(), vname in self.variables, vname

        #if not vname in self.variables :
        #    raise IOError('unknown variable')

        self.load_all_variable( vname )

        #print 'available ', self.variables[vname].keys()

        ret = zeros([self.n_ens]+list(self.variables[vname][1].shape))
        print('ret shape', ret.shape)
        for i in range(self.n_ens) :
            ret[i,...] = self.variables[vname][i+1]
        return ret

    def get_mean_and_spread_of_variable( self, vname ) :
        ensvar = self.get_ensemble_variable( vname )
        return ensvar.mean(axis=0), ensvar.std(axis=0,ddof=1)

    def load_coordinates( self ) :

        if self.lat is None or self.lon is None :
            fname = self.xp.visop_filename( self.starttime, fcsttime=self.fcsttime, memidx=-1, channel=self.channel, lfcst=self.lfcst )
            fname_lat = fname.replace('refl_','lat_')
            fname_lon = fname.replace('refl_','lon_')

            # dirty fix for T.Necker (sorry):
            file_path = os.path.abspath(__file__)
            dir_path = os.path.dirname(file_path)
            if not os.path.exists(fname_lat) :
                fname_lat = dir_path+'/lat_seviri.npy'
            if not os.path.exists(fname_lon) :
                fname_lon = dir_path+'/lon_seviri.npy'

            self.lat = load(fname_lat)
            self.lon = load(fname_lon)

        return self.lat, self.lon

    def coordinates_to_indices( self, lon, lat, method='nearest'  ) :
        """Transform (lon[i,j],lat[i,j]) coordinates into (i,j) pixel indices"""

        import scipy.interpolate
        dbg = False

        self.load_coordinates()
        rlat, rlon = self.lat, self.lon
        nlon, nlat = rlat.shape

        if dbg :
            print(('RLAT variation with first  index ', rlat[:5,5]))
            print(('RLAT variation with second index ', rlat[5,:5], '--> FASTER'))
            print(('RLON variation with first  index ', rlon[:5,5], '--> FASTER'))
            print(('RLON variation with second index ', rlon[5,:5]))
            print('--> RLAT[ILON,ILAT]')

        ilat = transpose( arange(nlat).repeat(nlon).reshape((nlat,nlon)) )
        ilon =            arange(nlon).repeat(nlat).reshape((nlon,nlat))

        if dbg :
            print(('ILAT variation with first  index ', ilat[:5,5]))
            print(('ILAT variation with second index ', ilat[5,:5], '--> FASTER'))
            print(('ILON variation with first  index ', ilon[:5,5], '--> FASTER'))
            print(('ILON variation with second index ', ilon[5,:5]))

        points = transpose(vstack((rlon.ravel(),rlat.ravel())))
        if method == 'nearest' : # fast, results are integers
            ilat_itp = scipy.interpolate.griddata( points, ilat.ravel(), (lon,lat), method='nearest', fill_value=-1)
            ilon_itp = scipy.interpolate.griddata( points, ilon.ravel(), (lon,lat), method='nearest', fill_value=-1)
        else : # e.g. method = 'linear' : slower but more accurate, results are floats
            ilat_itp = scipy.interpolate.griddata( points, ilat.ravel().astype(float), (lon,lat), method=method, fill_value=-1)
            ilon_itp = scipy.interpolate.griddata( points, ilon.ravel().astype(float), (lon,lat), method=method, fill_value=-1)

        # set indices for points outside domain to -1
        thres = self.lat[1,1] - self.lat[1,0]

        if dbg :
            print(('max. lat error : ', abs(lat-self.lat[ilon_itp,ilat_itp]).max()))
            print(('max. lon error : ', abs(lon-self.lon[ilon_itp,ilat_itp]).max()))
            print(('threshold : ', thres))

        idcs = where( (abs(lat-self.lat[ilon_itp,ilat_itp]) > thres) | (abs(lon-self.lon[ilon_itp,ilat_itp])>thres) )
        ilat_itp[idcs] = -1
        ilon_itp[idcs] = -1

        return ilon_itp, ilat_itp

    def i2o( self, quan, settings='experiment' ) :
        """Return quantity <quan> (can be 'obs', 'meq', 'lat', 'lon') that has been converted from the satellite
           images using visop_i2o with the specified settings."""

        if settings == 'experiment' :
            settings_ = self.xp.settings['VISOP_I2O_SETTINGS']
        else :
            settings_ = settings

        if not settings_ in self.i2o_data :
            self.transform_i2o(settings_)

        if not quan in self.i2o_data[settings_] :
            self.compute_i2o_quan(settings_,quan)

        return self.i2o_data[settings_][quan]

    def compute_i2o_quan(self,settings,quan) :

        if quan == 'ensmean' :  # ensemble mean of model equivalents [array]
            self.i2o_data[settings][quan] = self.i2o_data[settings]['meq'].mean(axis=0)

        elif quan == 'rmse' :   # RMSE of ensemble mean [scalar]
            self.i2o_data[settings][quan] = sqrt( ((self.i2o_data[settings]['obs'] - self.i2o('ensmean',settings=settings))**2).mean() )
        elif quan.startswith('rmse_mem') : # RMSE of a certain member
            m = int(quan[8:])
            self.i2o_data[settings][quan] = sqrt( ((self.i2o_data[settings]['obs'] - self.i2o_data[settings]['meq'][m-1,...])**2).mean() )

        elif quan == 'bias' :   # bias of ensemble mean [scalar]
            self.i2o_data[settings][quan] = (self.i2o('ensmean',settings=settings) - self.i2o_data[settings]['obs']).mean()
        elif quan.startswith('bias_mem') : # bias of a certain member
            m = int(quan[8:])
            self.i2o_data[settings][quan] = (self.i2o_data[settings]['meq'][m-1,...] - self.i2o_data[settings]['obs']).mean()

        elif quan == 'spread' : # spread = square root of mean ensemble variance [scalar]
            self.i2o_data[settings][quan] = sqrt( self.i2o_data[settings]['meq'].var(axis=0,ddof=1).mean() )

        elif quan.startswith('brier') : # brier [skill] score and decomposition
            thres = float(quan[5:])
            self.i2o_data[settings][quan] = brier_score( self.i2o_data[settings]['obs'],
                                                         self.i2o_data[settings]['meq'][:self.n_ens,...], thres, components=True )
        elif quan.startswith('fss') : # fractions skill score and decomposition + believable scale
            thres = float(quan[3:])
            windows = [1,2,3,4,6,8,10,15,20,30] # assuming units ~6km #arange(5,101,5)
            self.i2o_data[settings][quan] = fss_ens_dict( self.i2o_data[settings]['meq'][:self.n_ens,...],
                                                          self.i2o_data[settings]['obs'],
                                                          windows, [thres], believable_scale=True )
            self.i2o_data[settings][quan]['fss_random'], self.i2o_data[settings][quan]['fss_target'] = \
                fss_random_target( self.i2o_data[settings]['obs'], [thres] )
            self.i2o_data[settings][quan]['windows'] = windows

        elif quan.startswith('clc') and not quan.startswith('clc_tot') :
            thres = float(quan[3:5])/100
            what  = quan[6:]
            print(('computing domain cloud cover for %s (threshold %f)...' % (what,thres)))
            if what in ['det','ensmean','obs'] :
                f = self.i2o(what,settings=settings)
            else :
                memidx = int(what)
                f = self.i2o('meq',settings=settings)[memidx-1,...]
            self.i2o_data[settings][quan] = len(where(f>thres)[0])/float(len(f))

        else :
            raise ValueError('visop_ensemble.compute_i2o: I do not know how to compute %s ...'%quan)

    def transform_i2o( self, settings, det=None ) :
        """Transform ensemble data using visop_i2o with the specified settings."""

        if det is None :
            det = False if self.lfcst else True

        if self.verbose : print(('transform_i2o with settings ', settings))

        if settings in self.i2o_data :
            print('WARNING: settings %s are already in i2o_data -- transforming again...')
        else :
            self.i2o_data[settings] = {}

        self.load_all_reflectances( obs=True, det=det )
        self.load_coordinates()

        self.i2o_data[settings]['obs'],\
        meq1,\
        self.i2o_data[settings]['lat'],\
        self.i2o_data[settings]['lon'] = transform_variables( self.reflectance[-1],
                                                              self.reflectance[1],
                                                              self.lat, self.lon, settings )

        self.i2o_data[settings]['meq'] = zeros( [self.n_ens]+list(meq1.shape) )
        self.i2o_data[settings]['meq'][0,...] = meq1
        for i in range(2,self.n_ens+1) :
            self.i2o_data[settings]['meq'][i-1,...] = transform_variables( self.reflectance[-1],
                                                                           self.reflectance[i],
                                                                           self.lat, self.lon, settings )[1]
        # FIXME: it would be sufficient to transform only meq...
        if det :
            self.i2o_data[settings]['det'] = transform_variables( self.reflectance[-1],
                                                                  self.reflectance[0],
                                                                  self.lat, self.lon, settings )[1]
        if not self.addvars is None :
            if self.verbose : print('visop_ensemble.transform_i2o: transforming additional variables...')
            for vname in self.addvars :
                self.load_all_variable(vname)
                self.i2o_data[settings][vname] = zeros( [self.n_ens]+list(meq1.shape) )
                for i in range(1,self.n_ens+1) :
                    self.i2o_data[settings][vname][i-1,...] = transform_variables( self.reflectance[-1],
                                                                           self.variables[vname][i],
                                                                           self.lat, self.lon, settings )[1]
                    self.i2o_data[settings][vname+'_mean']   = self.i2o_data[settings][vname].mean(axis=0)
                    self.i2o_data[settings][vname+'_spread'] = self.i2o_data[settings][vname].std(axis=0,ddof=1)

    def eval_region( self, binary=False ) :
        """Return index list of evaluation region or a binary field which is True for pixels in the evaluation region"""
        
        s = self.xp.settings
        lonmin = float(s['VISOP_LONMIN'])
        lonmax = float(s['VISOP_LONMAX'])
        latmin = float(s['VISOP_LATMIN'])
        latmax = float(s['VISOP_LATMAX'])

        # FIXME: should be read from satellite data used in KENDA
        #import visop.seviri, visop.geometry
        #lat, lon = visop.seviri.read_seviri_reflectance( coordinates=True, silence=True )

        lat, lon = self.load_coordinates()

        idcs = where( (lat>latmin) & (lat<latmax) & (lon>lonmin) & (lon<lonmax) )

        if binary :
            region = zeros( lat.shape, dtype=int )
            region[ idcs ] = 1
            return region
        else :
            return idcs

    def histogram( self, region=None ) :
        """Compute reflectance histogram"""
        
        if region is None : region = self.eval_region(binary=True)

        print('implement me')


    def rmse( self, i2o='' ) :
        """Compute global rmse"""
        if not 'rmse' in list(self.statistics.keys()) :
            self.statistics['rmse'] = sqrt( (self.rmse2d()[self.eval_region()]**2).mean() )
        return self.statistics['rmse']

    def rmse2d( self ) :
        """Compute RMSE for each pixel"""
        if not 'rmse2d' in list(self.statistics.keys()) : 
            self.load_all_reflectances( obs=True, det=False )
            self.statistics['rmse2d'] = zeros(self.reflectance[1].shape)
            for i in range(1,int(self.xp.settings['N_ENS'])+1) :
                self.statistics['rmse2d'] +=  (self.reflectance[i] - self.reflectance[-1])**2
            self.statistics['rmse2d'] = sqrt( self.statistics['rmse2d'] / int(self.xp.settings['N_ENS']) )
        return self.statistics['rmse2d']
    
    def mean( self, i2o=''  ) :
        if not 'mean' in list(self.statistics.keys()) :
            self.statistics['mean'] = self.mean2d()[self.eval_region()].mean()
        return self.statistics['mean']

    def mean2d( self ) :
        """compute ensemble mean"""
        if not 'mean2d' in list(self.statistics.keys()) : 
            self.load_all_reflectances( obs=False, det=False )
            self.statistics['mean2d'] = zeros(self.reflectance[1].shape)
            for i in range(1,int(self.xp.settings['N_ENS'])+1) :
                self.statistics['mean2d'] += self.reflectance[i]/int(self.xp.settings['N_ENS'])
        return self.statistics['mean2d']

    def spread( self, i2o=''  ) :
        """Compute global mean spread"""
        if not 'spread' in list(self.statistics.keys()) :
            self.statistics['spread'] = self.spread2d()[self.eval_region()].mean()
        return self.statistics['spread']

    def spread2d( self ) :
        """Compute spread for each pixel"""
        if not 'spread2d' in list(self.statistics.keys()) : 
            self.load_all_reflectances( obs=False, det=False )
            self.statistics['spread2d'] = zeros(self.reflectance[1].shape)
            for i in range(1,int(self.xp.settings['N_ENS'])+1) :
                self.statistics['spread2d'] +=  (self.reflectance[i] - self.mean2d())**2
            self.statistics['spread2d'] = sqrt( self.statistics['spread2d'] / (1 + int(self.xp.settings['N_ENS'])) )
        return self.statistics['spread2d']

    def bias( self, i2o=''  ) :
        """"Compute global bias"""
        if not 'bias' in list(self.statistics.keys()) :
            self.statistics['bias'] = self.bias2d()[self.eval_region()].mean()
        return self.statistics['bias']

    def bias2d( self ) :
        """Compute bias for each pixel"""
        if not 'bias2d' in list(self.statistics.keys()) : 
            self.load_all_reflectances( obs=True, det=False )
            self.statistics['bias2d'] = self.mean2d() - self.reflectance[-1]
        return self.statistics['bias2d']

    def probex( self, thres=0.5 ) :
        """Compute probability to exceed threshold thres for each pixel"""

        self.load_all_reflectances( obs=False, det=False )
        probex = zeros(self.reflectance[1].shape)
        for i in range(1,int(self.xp.settings['N_ENS'])+1) :
            probex[ where( self.reflectance[i] > thres ) ] += 1.0
        return probex / self.xp.n_ens

    def areafrac_obs( self, thres=0.3 ) :
        """Compute fraction of pixels for which observed reflectance > threshold value"""
        return len( where( self.reflectance[-1] > thres )[0] ) / float(self.reflectance[-1].size)

    def areafrac_ens( self, thres=0.3 ) :
        """Compute fractions of pixels for which member reflectance > threshold value"""
        self.load_all_reflectances( obs=True, det=False )
        areafrac = zeros(self.xp.n_ens)
        for i in range(1,self.xp.n_ens+1) :
            areafrac[i-1] = len( where( self.reflectance[i] > thres )[0] ) / float(self.reflectance[i].size)
        return areafrac

    def contingency_scores( self, thres=0.5 ) :
        """Compute equitable threat score"""

        # see http://journals.ametsoc.org/doi/full/10.1175/2009WAF2222350.1

        self.load_all_reflectances( obs=False, det=False )
        hit  = zeros(self.reflectance[1].shape) # A
        falm = zeros(self.reflectance[1].shape) # B
        miss = zeros(self.reflectance[1].shape) # C
        cneg = zeros(self.reflectance[1].shape) # D

        for i in range(1,int(self.xp.settings['N_ENS'])+1) :
            hit[  where( ( self.reflectance[i]  > thres ) & ( self.reflectance[-1]  > thres ) ) ] += 1.0/self.xp.n_ens
            falm[ where( ( self.reflectance[i]  > thres ) & ( self.reflectance[-1] <= thres ) ) ] += 1.0/self.xp.n_ens
            miss[ where( ( self.reflectance[i] <= thres ) & ( self.reflectance[-1]  > thres ) ) ] += 1.0/self.xp.n_ens
            cneg[ where( ( self.reflectance[i] <= thres ) & ( self.reflectance[-1] <= thres ) ) ] += 1.0/self.xp.n_ens
            
        a = hit
        b = falm
        c = miss
        d = cneg

        scores = { 'hit':hit, 'falm':falm, 'miss':miss, 'cneg':cneg }

        # DOES NOT MAKE MUCH SENSE

        scores['hitrate'] = (hit+cneg) / (hit+cneg+miss+falm)       # hit rate

        idcs = where( hit+falm > 1e-6 )
        print(('faratio : %d valid pixels' % len(idcs[0])))
        scores['faratio'] = 0*hit
        scores['faratio'][idcs] = falm[idcs] / (hit+falm)[idcs]     # false alarm ratio

        idcs = where( hit+miss > 1e-6 )
        print(('prodec : %d valid pixels' % len(idcs[0])))
        scores['probdec'] = 0*hit
        scores['probdec'][idcs] = hit[idcs]  / (hit+miss)[idcs]     # probability of detection

        idcs = where( hit+falm+miss > 1e-6 )
        print(('csi : %d valid pixels' % len(idcs[0])))
        scores['csi'] = 0*hit
        scores['csi'][idcs] = hit[idcs] / (hit+falm+miss)[idcs]     # critical success index = threat score

        dnom = ((a+c)*(c+d) + (a+b)*(b+d))
        num  = 2*(a*d-b*c)
        idcs = where( dnom > 1e-6 )
        print(('hss : %d valid pixels' % len(idcs[0])))
        print(('--dnom : ', dnom.min(), dnom.mean(), dnom.max()))
        print(('--num  : ', num.min(),  num.mean(),  num.max()))
        scores['hss'] = 0*hit
        scores['hss'][idcs]     = num[idcs]/dnom[idcs]      # Heidke skill score
        print(('--hss  : ', scores['hss'].min(),  scores['hss'].mean(),  scores['hss'].max()))

        scores['ets']     = scores['hss']/(2-scores['hss'])         # Gilbert score (="equitable skill score")

        idcs = where( (hit+miss > 1e-6) & (falm+cneg > 1e-6) )
        print(('pss : %d valid pixels' % len(idcs[0])))
        scores['pss'] = 0*hit
        scores['pss'][idcs]     = hit[idcs]/(hit+miss)[idcs] - falm[idcs]/(falm+cneg)[idcs]  # Peirce skill score

        return scores


if __name__ == "__main__": # ===========================================================================================

    from pylab import *

    xp = Experiment(sys.argv[1],verbose=True)
    vens = xp.get_visop('20160605100000',fcsttime=60,lfcst=False)

    if False : # coordinate transformation test
        print('reading coordinates...')
        vens.load_coordinates()

        print('transforming indices back and forth...')
        i1, j1, = [0,90,33,55,120], [0,2,55,77,123]
        i2, j2 = vens.coordinates_to_indices( vens.lon[i1,j1], vens.lat[i1,j1], method='nearest' )
        print(i1)
        print(i2)
        print(j1)
        print(j2)

        #äsys.exit(0)

        lat2d, lon2d = meshgrid( linspace(30,70,100), linspace(0,30,80) )
        i, j = vens.coordinates_to_indices( lon2d, lat2d, method='nearest' )

        print(('shapes:', i.min(), i.max(), j.min(), j.max(), vens.lat.shape))

        figure(2, figsize=(10,10))

        clf(); imshow( vens.lat, origin='lower' ); colorbar(); savefig('lat.png')
        clf(); imshow( vens.lon, origin='lower' ); colorbar(); savefig('lon.png')
        clf(); imshow( lat2d, origin='lower' ); colorbar(); savefig('lat2d.png')
        clf(); imshow( lon2d, origin='lower' ); colorbar(); savefig('lon2d.png')

        clf(); imshow( i, origin='lower' ); colorbar(); savefig('i2d.png')
        clf(); imshow( j, origin='lower' ); colorbar(); savefig('j2d.png')

        clf(); imshow( vens.lat[i,j], origin='lower' ); colorbar(); savefig('lat_rep.png')
        clf(); imshow( vens.lon[i,j], origin='lower' ); colorbar(); savefig('lon_rep.png')

        sys.exit(0)

    tauw = vens.get_ensemble_variable('tauw')
    print('tauw : ', tauw.shape, tauw.mean())

    # i2o settings from experiment
    print((vens.i2o('rmse')))

    # custom i2o setting : restrict to COSMO-DE, no transformations
    cde='LATLON:COSMO-DE'
    print((vens.i2o('rmse',settings=cde)))



    figure(1, figsize=(10,10))
    clf()
    scatter( vens.i2o('lon', settings=cde), vens.i2o('lat', settings=cde), color='b', alpha=0.1, s=0.1 )
    scatter( vens.i2o('lon'), vens.i2o('lat'), color='r' )
    savefig('obsloc.png')

    #cs=xp.get_cosmo(xp.lfcst_sfc_output_times[1],lfcst_time=xp.lfcst_start_times[0],prefix='lfff',suffix='sfc',member=1)
    #clf()
    #imshow( cs['TOT_PREC'] )
    #savefig('tot_prec.png')
