#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . V I S O P _ F C S T
#  retrieve & postprocess visop data for ensemble forecasts generated by KENDA
#
#  2017.3 L.Scheck 

from __future__ import absolute_import, division, print_function
# import matplotlib/pylab such that it does not require a X11 connection
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
import matplotlib.gridspec as gridspec

import sys, os, argparse
import pickle as pickle
from numpy import *

from kendapy.experiment import Experiment
from kendapy.time14 import Time14, time_range
from kendapy.binplot import binplot
from kendapy.visop_i2o_em import area_settings


#--------------------------------------------------------------------------------
def get_visop_fcst_stats( xp_, times=None, channel='VIS006', cache=True, recompute=False,
                          lfcst=True, error_evolution=True, clc_evolution=True, multiscale=True, verbose=False ) :
    """Retrieve visop data from ensemble forecasts started at the specified times and compute basic statistics"""

    vfs_version = 'V0.2' # change this to mark cache files as deprecated

    if cache : # force all features to be switched on -- we do not want incomplete cache files...
        lfcst=True
        error_evolution=True
        clc_evolution=True
        multiscale=True

    if isinstance(xp_, str) : # xp_ is a path
        xp = Experiment(xp_)
    else :                           # xp_ is a Experiment object
        xp = xp_

    if verbose : print(('experiment %s : %s #members, first fcst start time %s, last analysis time %s' % ( \
                       xp.settings['exp'], xp.settings['N_ENS'], xp.fcst_start_times[0], xp.veri_times[-1] )))

    # determine time range
    if times is None :
        times = xp.veri_times
    if verbose : print(('fcst start times: ', times))
    fcsttimes = xp.visop_fcsttimes()

    # multiscale analysis
    scales = list(map( int, xp.settings['VISOP_EVAL_SCALES'].split(',') ))   #[1,2,4,8,16,32,64]
    refl_thresholds = [ 0.2, 0.25, 0.3, 0.4, 0.5, 0.6 ]
    fss_windows = None

    # return value
    rs = None

    if cache :
        # construct cache file name
        cachefpath = xp.settings['PLOT_DIR'] + '/cache/visop_fcst_stats/'
        if not os.path.exists(cachefpath) :
            os.system('mkdir -p '+cachefpath)

        # construct cache file name
        features = ('L' if lfcst else '') + ('E' if error_evolution else '') + ('C' if clc_evolution else '') \
                 + ('M' if multiscale else '')
        cachefname = 'VFS_%s_%s-%s_%s_%s.pickle' % (vfs_version,times[0],times[-1],features,channel)

        if os.path.exists(cachefpath+cachefname) and not recompute :
            print(('loading %s%s ...' % (cachefpath,cachefname)))
            with open( cachefpath+cachefname, 'rb') as f :
                rs = pickle.load(f)
        else :
            if recompute :
                print(('ignoring existing cache file %s%s ...' % (cachefpath,cachefname)))
            else :
                print(('cache file %s%s does not yet exist...' % (cachefpath,cachefname)))

    if rs is None :
        stats = {}
        clc   = {}
        mstat = { 'scales':scales, 'refl_thresholds':refl_thresholds }
        for t in times :
            stats[t] = {}
            clc[t]   = {}
            mstat[t] = {}
            for fcsttime in fcsttimes :

                # gather data from cycling forecasts .....................................................

                fname0 = xp.visop_filename( t, fcsttime=fcsttime, memidx=0, channel=channel )
                if not os.path.exists(fname0) :
                    print(('does not exist : ', fname0))
                    continue
                #base_pfname = fname0.split('/')[-1].replace('.000.npy','')

                print(('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime)))
                vens = xp.get_visop( t, fcsttime=fcsttime, channel=channel )
                #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                if error_evolution :
                    stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=xp.settings['VISOP_I2O_SETTINGS']),
                                           'spread': vens.i2o('spread', settings=xp.settings['VISOP_I2O_SETTINGS']),
                                           'rmse':   vens.i2o('rmse',   settings=xp.settings['VISOP_I2O_SETTINGS']) }
                    #print 'stats : ', stats[t][fcsttime]

                    # fractions skill score
                    for refl_thres in refl_thresholds :
                        fssthres = 'fss%.2f' % refl_thres
                        print(('computing FSS ', fssthres, ' for cycling'))
                        stats[t][fcsttime][fssthres] = vens.i2o( fssthres, settings='SUPEROBB:%d,%d_%s' % (2,1,xp.settings['VISOP_EVAL_AREA']) )
                        if fss_windows is None : fss_windows = stats[t][fcsttime][fssthres]['windows']

                if multiscale :
                    mstat[t][fcsttime] = {}
                    for s in scales :
                        #settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                        settings = 'SUPEROBB:%d,%d_%s' % (2*s,s,xp.settings['VISOP_EVAL_AREA'])
                        mstat[t][fcsttime][s] = { 'settings':settings,
                                                  'bias':   vens.i2o('bias',   settings=settings),
                                                  'spread': vens.i2o('spread', settings=settings),
                                                  'rmse':   vens.i2o('rmse',   settings=settings) }
                        if True : # do it for all members
                            for m in range(1,xp.n_ens+1) :
                                mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                        # Brier score
                        for refl_thres in refl_thresholds :
                            brierthres = 'brier%.2f' % refl_thres
                            mstat[t][fcsttime][s][brierthres] = vens.i2o(brierthres,settings=settings)

                        #print ('scale %02d : '%s), mstat[t][fcsttime][s]

                if clc_evolution :
                    # extract area information, get rid of all transformations (superobbing etc.)
                    area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                    clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                         'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                         'det30':    vens.i2o('clc30_det',    settings=area),
                                         'obs60':    vens.i2o('clc60_obs',    settings=area),
                                         'ensmean60':vens.i2o('clc60_ensmean',settings=area),
                                         'det60':    vens.i2o('clc60_det',    settings=area) }
            # end of visop output times
        # end of fcst start times

        # gather data from long forecasts .....................................................
        if lfcst :
            print()
            print('Gathering data from long forecasts...')
            lfcst_stats = { 'refl_thresholds':refl_thresholds }
            lfcst_clc   = {}
            lfcst_mstat = { 'scales':scales, 'refl_thresholds':refl_thresholds }
            for t in times :
                print('time ', t, end=' ')
                if t in xp.lfcst_start_times :
                    print('is relevant')
                    lfcst_stats[t] = {}
                    lfcst_clc[t]   = {}
                    lfcst_mstat[t] = {}
                    for fcsttime in xp.lfcst_visop_output_times_min :
                        fname1 = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=True )
                        if not os.path.exists(fname1) :
                            print(('does not exist : ', fname1))
                            continue
                        #base_pfname = fname1.split('/')[-1].replace('.001.npy','')

                        print(('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime)))
                        vens = xp.get_visop( t, fcsttime=fcsttime, channel=channel, lfcst=True )
                        #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                        if error_evolution :
                            lfcst_stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=xp.settings['VISOP_I2O_SETTINGS']),
                                                         'spread': vens.i2o('spread', settings=xp.settings['VISOP_I2O_SETTINGS']),
                                                         'rmse':   vens.i2o('rmse',   settings=xp.settings['VISOP_I2O_SETTINGS']) }
                            #print 'stats : ', lfcst_stats[t][fcsttime]

                            # fractions skill score
                            for refl_thres in refl_thresholds :
                                fssthres = 'fss%.2f' % refl_thres
                                print(('computing FSS ', fssthres, ' for long forecasts'))
                                lfcst_stats[t][fcsttime][fssthres] = vens.i2o( fssthres, settings='SUPEROBB:%d,%d_%s' % (2,1,xp.settings['VISOP_EVAL_AREA']) )
                                if fss_windows is None : fss_windows = lfcst_stats[t][fcsttime][fssthres]['windows']

                        if multiscale :
                            lfcst_mstat[t][fcsttime] = {}
                            for s in scales :
                                #settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                                settings = 'SUPEROBB:%d,%d_%s' % (2*s,s,xp.settings['VISOP_EVAL_AREA'])
                                lfcst_mstat[t][fcsttime][s] = { 'settings':settings,
                                                          'bias':   vens.i2o('bias',   settings=settings),
                                                          'spread': vens.i2o('spread', settings=settings),
                                                          'rmse':   vens.i2o('rmse',   settings=settings) }
                                if True : # do it for all members
                                    for m in range(1,xp.n_ens+1) :
                                        lfcst_mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                        lfcst_mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                                #print ('scale %02d : '%s), mstat[t][fcsttime][s]
                                # Brier score
                                for refl_thres in refl_thresholds :
                                    brierthres = 'brier%.2f' % refl_thres
                                    lfcst_mstat[t][fcsttime][s][brierthres] = vens.i2o(brierthres,settings=settings)

                        if clc_evolution :
                            # extract area information, get rid of all transformations (superobbing etc.)
                            area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                            lfcst_clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                                       'det30':    vens.i2o('clc30_001',    settings=area),
                                                       'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                                       'obs60':    vens.i2o('clc60_obs',    settings=area),
                                                       'det60':    vens.i2o('clc60_001',    settings=area),
                                                       'ensmean60':vens.i2o('clc60_ensmean',settings=area) }
                            #print '>>> lfcst_clc ', lfcst_clc[t][fcsttime]

                    # end of visop output times
            # end of fcst start times
        # end of long forecasts .....................................................................

        rs = { 'times':times, 'scales':scales, 'refl_thresholds':refl_thresholds }
        if not fss_windows is None :
            rs['fss_windows'] = fss_windows

        if error_evolution : rs['stats'] = stats
        if clc_evolution   : rs['clc']   = clc
        if multiscale      : rs['mstat'] = mstat
        if lfcst :
            if error_evolution : rs['lfcst_stats'] = lfcst_stats
            if clc_evolution   : rs['lfcst_clc']   = lfcst_clc
            if multiscale      : rs['lfcst_mstat'] = lfcst_mstat

        if cache :
            print(('saving cache file to %s%s ...' % (cachefpath,cachefname)))
            with open( cachefpath+cachefname, 'wb') as f :
                pickle.dump( rs, f, pickle.HIGHEST_PROTOCOL )

    return rs

#-------------------------------------------------------------------------------
if __name__ == "__main__": # ---------------------------------------------------
#-------------------------------------------------------------------------------

    rs = get_visop_fcst_stats(sys.argv[1],verbose=True)
    print()
    print('Available data:')
    stats = rs['stats']
    lfcst_stats = rs['lfcst_stats']
    for t in sorted(stats.keys()) :
        print(('> ', t, list(stats[t].keys())))
        if t in lfcst_stats :
            print(('  --> LFCST ', sorted(lfcst_stats[t].keys())))
