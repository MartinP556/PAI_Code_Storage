#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . P L O T _ V I S O P
#  postprocess VISOP results generated by KENDA experiments
#
#  2017.3 L.Scheck 

from __future__ import absolute_import, division, print_function
# import matplotlib/pylab such that it does not require a X11 connection
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.colors import LinearSegmentedColormap

import sys, os, argparse
from numpy import *
from kendapy.experiment import Experiment
from kendapy.time14 import Time14, time_range
from kendapy.binplot import binplot
from kendapy.visop_i2o_em import area_settings
from kendapy.precprod_ens import get_precprod_ens, get_precprod_member

#-----------------------------------------------------------------------------------------------------------------------
def plot_reflectance( r, name, fname, vmin=0.0, vmax=1.0, infos=True, notext=False, grid=False, lat=None, lon=None,
                      contours=0, cmap=None, spag=None, cfield=None, cfield_alpha=0.2, cfield_color='#0099dd', thres=0.5,
                      scat_lat=None, scat_lon=None, scat_txt=None, scat_col='#ff00ff', scatter=None,
                      cpath=None, cpath_color='r', verbose=False ) :
    """Low-level routine for plotting satellite-image like data"""

    if verbose :
        print(('field shape : ', r.shape))
        if not lat is None : print(('lat   shape : ', lat.shape))
        if not lon is None : print(('lon   shape : ', lon.shape))

    plt.figure( 88, figsize=(6,6) )
    plt.clf()

    if vmax is None : vmax = r.max()
    if vmin is None : vmin = r.min()

    if verbose : print(('vmin = %f, vmax = %f' % (vmin,vmax)))

    if vmin*vmax >= 0 :
        plt.gray()
        cmapn='gray'
        ctext='r'
    else :
        cmapn='RdBu'
        ctext='r'

    if not (cmap is None) :
        if type(cmap) == type('abc') :
            cmap_ = plt.get_cmap(cmap)
        else :
            cmap_ = cmap
    else :
        cmap_ = plt.get_cmap(cmapn)


    nx_seviri, ny_seviri = r.shape

    plt.axes((0.1,0.1,0.85,0.85*float(ny_seviri)/float(nx_seviri)))
    img = plt.imshow( transpose(r[:,::-1]), vmin=vmin, vmax=vmax, extent=[ 0, nx_seviri, 0, ny_seviri ], aspect=1.0,
                      cmap=cmap_, interpolation='nearest' ) #, cmap=get_cmap('gist_ncar') )
    #img = imshow( transpose(r[:,::-1]), vmin=vmin, vmax=vmax, extent=[ 0, nx_seviri, 0, ny_seviri ], aspect=1.0, cmap=get_cmap(cmapn) )
    if not notext:
        plt.text( 2, 2, name, color=ctext, size=11 ) #, weight="bold") #, family='TeX Gyre Adventor'
    if infos :
        plt.text( 10, 10, ('mean abs. value: %f, RMS %f' % ( abs(r).mean(), sqrt((r**2).mean()) ) ), color=ctext, size=11, weight="bold" )

    if grid :
        #lat, lon = read_seviri_reflectance( coordinates=True, silence=True )

        lats = arange(30,60)
        clat = plt.contour( transpose(lat), levels=lats, linewidths=0.3, colors='r', alpha=0.5 )
        clat = plt.contour( transpose(lat), levels=lats[::5], linewidths=0.45, colors='r', alpha=0.5 )
        #clabel( clat, levels[0::5], inline=1, fmt='%2.0f', fontsize=10 )

        lons = arange(0,30)
        clon = plt.contour( transpose(lon), levels=lons, linewidths=0.3, colors='r', alpha=0.5 )
        clon = plt.contour( transpose(lon), levels=lons[::5], linewidths=0.45, colors='r', alpha=0.5 )
        #clabel( clon, levels[0::5], inline=1, fmt='%2.0f', fontsize=10 )


        #print( '--------------------------' )
        #print( lat[0,0], lat[0,1], lat[1,0] ) # --> lat changes with dim 1
        #print( lon[0,0], lon[0,1], lon[1,0] ) # --> lon changes with dim 0
        #print()

        yticks = []
        yticklabels = []
        latvec = lat[0,:].ravel()
        for l in lats :
            if l%5==0 and l > latvec.min() and l< latvec.max() :
                #print('-'*50)
                #print(latvec)
                j = argmin(abs(latvec-l))
                #print( l, j )
                #plt.text( 1, j, r'${:.0f}^\circ$'.format(l), fontsize=10, color='r', ha='left', va='bottom' )
                yticks.append(j)
                yticklabels.append(r'${:.0f}$N'.format(l))
        #print()
        xticks = []
        xticklabels = []
        lonvec = lon[:,0].ravel()
        for l in lons :
            if l%5==0 and l > lonvec.min() and l< lonvec.max() :
                i = argmin(abs(lonvec-l))
                #plt.text( i, 1, r'${:.0f}^\circ$'.format(l), fontsize=10, color='r', ha='center', va='bottom' )
                xticks.append(i)
                xticklabels.append(r'${:.0f}$E'.format(l))
        plt.xticks( xticks, xticklabels )
        plt.yticks( yticks, yticklabels )
        plt.tick_params(length=0)

    if type(contours) == type(zeros(2)) :                                    # 0.6       0.65        0.7      0.75      0.8       0.85      0.9       0.95
        cnt = plt.contour( transpose(r), levels=contours, linewidths=0.3, colors=['#ff00ff', '#6600ff', '#0000ff','#0099ff','#00cc00','#cccc00','#ff0000','#ff00ff'] )
        #clabel(cnt, inline=1, fontsize=10)
    else :
        if contours > 0 :
            cnt = plt.contour( transpose(r), levels=linspace(vmin,vmax,contours), linewidths=0.3, colors='r' )
            plt.clabel(cnt, inline=1, fontsize=10)

    if not spag is None :
        for i in reversed(sorted(spag.reflectance.keys())) :
            if i == -1 : # obs
                lw=1
                col='#0099dd'
                al=1.0
            elif i == 0 : # det
                lw = 0.5
                col = '#990000'
                al=1.0
            else :
                lw = 0.3
                col = 'k'
                al=0.5
            plt.contour( transpose(spag[i]), levels=[thres], linewidths=lw, colors=col, alpha=al )
        plt.contourf( transpose(spag[-1]), levels=[thres,2], colors=col, alpha=0.2 )

    if not cfield is None :
        plt.contour( transpose(cfield), levels=[thres], linewidths=1.0, colors=cfield_color )
        plt.contourf( transpose(cfield), levels=[thres,cfield.max()*2], colors=cfield_color, alpha=cfield_alpha )

    if not scat_lat is None :

        if False :
            import scipy.interpolate

            print('adding scatter plot')

            nx, ny = lat.shape
            jgrid, igrid = meshgrid( arange(ny), arange(nx) )

            print(('nx, ny = ', nx, ny, lat.shape, igrid.shape, jgrid.shape))

            print(('first/second index variation of lat   ', lat[0:4,10],   '  /  ', lat[10,0:4]))
            print(('first/second index variation of lon   ', lon[0:4,10],   '  /  ', lon[10,0:4]))
            print(('first/second index variation of igrid ', igrid[0:4,10], '  /  ', igrid[10,0:4]))
            print(('first/second index variation of jgrid ', jgrid[0:4,10], '  /  ', jgrid[10,0:4]))

            # THIS DOES NOT WORK OR TAKES EXTREMELY LONG.
            i_interpolator = scipy.interpolate.interp2d( lat.ravel(), lon.ravel(), igrid.ravel() )
            j_interpolator = scipy.interpolate.interp2d( lat.ravel(), lon.ravel(), jgrid.ravel() )

            print('interpolators are set up...')

            scat_i, scat_j = i_interpolator(scat_lat,scat_lon), j_interpolator(scat_lat,scat_lon)

        # slow & stupid, but working...
        scat_i = zeros(scat_lat.shape)
        scat_j = zeros(scat_lat.shape)
        for k in range(scat_lat.size) :
            scat_i[k], scat_j[k] = unravel_index( argmin( abs(lat-scat_lat[k]) + abs(lon-scat_lon[k]) ), lat.shape )

        plt.scatter( scat_i, scat_j, color=scat_col, s=3 )
        if not scat_txt is None :
            for k in range(scat_i.size) :
                plt.text( scat_i[k], scat_j[k], ' '+scat_txt[k], fontsize=10, color=scat_col, ha='left', va='center' )

    # more general version
    if not scatter is None :
        # scatter is list of structures {'lat':..., 'lon':..., 'color':..., 'text':... }
        for sc in scatter :
            # slow & stupid, but working...
            sc_i = zeros(sc['lat'].shape)
            sc_j = zeros(sc['lat'].shape)
            for k in range(sc['lat'].size) :
                sc_i[k], sc_j[k] = unravel_index( argmin( abs(lat-sc['lat'][k]) + abs(lon-sc['lon'][k]) ), lat.shape )
            sc_col = sc['color'] if 'color' in sc else scat_col
            plt.scatter( sc_i, sc_j, color=sc_col, s=3 )
            if 'text' in sc :
                for k in range(sc_i.size) :
                    plt.text( sc_i[k], sc_j[k], ' '+sc['text'][k], fontsize=10, color=sc_col, ha='left', va='center' )

    if not cpath is None :
        plt.plot( cpath[0], cpath[1], cpath_color )

    cax = plt.axes(( 0.95, 0.1, 0.03, 0.85*float(ny_seviri)/float(nx_seviri) ))
    plt.colorbar( img, cax=cax )
    plt.savefig( fname, bbox_inches='tight' )
    #savefig( fname.replace('.png','')+'.eps', bbox_inches='tight' )
    print(('>>> plot_reflectance : saving %s ...' % fname))

#-----------------------------------------------------------------------------------------------------------------------
def probex_colormap( n, inverse=False, bad='#eeeeee' ) :
    """Create color map where the lowest and the highest 1/n fractions can clearly be distinguished from the linear
       range between 1/n and 1-1/n."""

    f_none = 1.0/n
    f_all  = 1.0 - f_none

    if inverse :
        c_all   = [ 0.0, 0.0,  0.0 ]
        c_high  = [ 0.2, 0.15, 0.1 ]
        c_low   = [ 1.0, 0.95, 0.9 ]
        c_none  = [ 1.0, 1.0,  1.0 ]
    else :
        c_none = [ 0.0, 0.0,  0.0 ]
        c_low  = [ 0.2, 0.15, 0.1 ]
        c_high = [ 1.0, 0.95, 0.9 ]
        c_all  = [ 1.0, 1.0,  1.0 ]

    # from https://matplotlib.org/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html?highlight=matplotlib%20colors%20linearsegmentedcolormap
    #
    # Each row in the table for a given color is a sequence of x, y0, y1 tuples. In each sequence, x must increase
    # monotonically from 0 to 1. For any input value z falling between x[i] and x[i+1], the output value of a given
    # color will be linearly interpolated between y1[i] and y0[i+1]:
    #
    # row i:   x  y0  y1
    #                /
    #               /
    # row i+1: x  y0  y1

    cdict = { 'red':   [( 0,      0,         c_none[0] ),
                        ( f_none, c_none[0], c_low[0]  ),
                        ( f_all,  c_high[0], c_all[0]  ),
                        ( 1.0,    c_all[0],  1.0       )],
              'green': [( 0,      0,         c_none[1] ),
                        ( f_none, c_none[1], c_low[1]  ),
                        ( f_all,  c_high[1], c_all[1]  ),
                        ( 1.0,    c_all[1],  1.0       )],
              'blue':  [( 0,      0,         c_none[2] ),
                        ( f_none, c_none[2], c_low[2]  ),
                        ( f_all,  c_high[2], c_all[2]  ),
                        ( 1.0,    c_all[2],  1.0       )] }

    cmap_name = 'probex%d'%n
    cmap = LinearSegmentedColormap( cmap_name, cdict )
    cmap.set_bad( bad, 1.0 )
    #cmap.set_over( '#00ff00', 1.0 )

    return cmap

#-----------------------------------------------------------------------------------------------------------------------
def plot_images( xp, start_time, output_time, args ) :

    fcsttime = output_time
    t = start_time
    tstamp = '%s+%dmin' % (start_time,output_time)

    titlestr = "%s T_win=%4.2fh e_o=%s h_loc=%s superobb=%s " % (
                xp.settings['EXPID'],
                float(xp.settings['ASSINT'])/3600.0,
                xp.settings['VISOP_ERROR'],
                xp.settings['VISOP_HLOC'],
                xp.settings['VISOP_SUPEROBB'])



    # determine output path and base file name

    if args.output_path != '' :
        if args.output_path != 'auto' :
            output_path = args.output_path+'/'
        else :
            if args.lfcst :
                output_path = xp.settings['PLOT_DIR']+'/visop/images_lfcst/%s/' % start_time
            else :
                output_path = xp.settings['PLOT_DIR']+'/visop/images_cycling/%s/' % start_time
            if not os.path.exists(output_path) :
                os.system('mkdir -p '+output_path)
    else :
        output_path = ''

    fname0 = xp.visop_filename( t, fcsttime=fcsttime, memidx=0, channel=channel, lfcst=args.lfcst )
    base_pfname = fname0.split('/')[-1].replace('.000.npy','')

    print(('plot will be named %s%s*.png ...' % (output_path,base_pfname)))

    if args.all_members :
        if args.lfcst :
            print('plotting images for obs / mean and all members ')
            members = [-1] + list(range(1,xp.n_ens+1))
        else :
            print('plotting images for obs / det / mean and all members ')
            members = list(range(-1,xp.n_ens+1))
    else :
        if args.lfcst :
            print('plotting images for obs / member 1 / mean')
            members = [-1,1]
        else :
            print('plotting images for obs / det / mean')
            members = [-1,0]
    if args.lfcst :
        i_det = 1
    else :
        i_det = 0

    # read data ........................................................................................................

    print(('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime)))
    if args.rt_input :
        addvars = ['tauw_mean','taui_mean','clc_tot']
    else :
        addvars = None
    vens = xp.get_visop( t, fcsttime=fcsttime, channel=args.channel, lfcst=args.lfcst, addvars=addvars )
    vens.load_coordinates()

    # parse crop region
    if  args.crop != '' :
        pxil, pxir, pxjb, pxjt = list(map( int, args.crop.split(',') ))
    else :
        pxil, pxir, pxjb, pxjt = 0, vens.lat.shape[0], 0, vens.lat.shape[1]

    # get VISOP assimilation region in pixel coordinates
    from kendapy.visop_i2o_em import area_settings
    from kendapy.area import parse_area_definition, convert_to_latlon
    rc, rcunits = parse_area_definition( area_settings( xp.settings['VISOP_I2O_SETTINGS'] ) )
    n = 10
    yy = list(linspace(rc[0],rc[2],n)) + list(zeros(n)+rc[2]) + list(linspace(rc[0],rc[2],n)[::-1]) + list(zeros(n)+rc[0])
    xx = list(zeros(n)+rc[1]) + list(linspace(rc[1],rc[3],n)) + list(zeros(n)+rc[3]) + list(linspace(rc[1],rc[3],n)[::-1])
    llat, llon = convert_to_latlon( yy, xx, input_units=rcunits )
    visop_assim_area = list( vens.coordinates_to_indices( llon, llat, method='nearest' ) )
    visop_assim_area[0] -= pxil
    visop_assim_area[1] -= pxjb

    if args.obsloc != '' : # obs from EKF file
        t_ana = (Time14(t) +Time14(xp.settings['ASSINT'])).string14()
        ekf = {}
        for obstype in args.obsloc.split(',') :
            try :
                ekf[obstype] = xp.get_ekf( t_ana, obstype, state_filter='all' )
            except IOError :
                print(obstype, ' is not available for ', t_ana)

    if args.precip :
        if args.lfcst :
            sfc_times   = xp.lfcst_sfc_output_times_min
            visop_times = xp.lfcst_visop_output_times_min
        else :
            sfc_times   = xp.sfc_output_times_min
            visop_times = xp.visop_output_times_min
        tresmin_sfc   = sfc_times[1]-sfc_times[0]
        tresmin_visop = visop_times[1]-visop_times[0]
        if tresmin_sfc != tresmin_visop :
            raise ValueError('tresmin_sfc != tresmin_visop : not yet implemented...')

        # The precipiation product is valid for [fcsttime,fcsttime+tresmin]
        # Should we plot it into the fcsttime or the fcsttime+tresmin image?
        # choice: plot [fcsttime,fcsttime+tresmin] product into fcsttime image,
        #         except for last image at fcsttime==sfc_time[-1], for which the
        #         same precipitation product as for sfc_time[-2] is used....
        if fcsttime < sfc_times[-1] :
            print(('reading precipitation ensemble for time [ %d, %d ] min...' % (fcsttime,fcsttime+tresmin_sfc)))
            pp = get_precprod_ens( xp, t, fcsttime, lfcst=args.lfcst, verbose=True, cache=None )
        else :
            print(('reading precipitation ensemble for time [ %d, %d ] min...' % (fcsttime-tresmin_sfc,fcsttime)))
            pp = get_precprod_ens( xp, t, fcsttime-tresmin_sfc, lfcst=args.lfcst, verbose=True, cache=None )

        tp_obs  = pp['obs']
        tp_ens  = pp['ens']
        clat    = pp['lat']
        clon    = pp['lon']
        tp_mean = tp_ens.mean(axis=0)

        # the same for the determionistic member
        if 0 in members :
            if fcsttime < sfc_times[-1] :
                print(('reading precipitation of det member for time [ %d, %d ] min...' % (fcsttime,fcsttime+tresmin_sfc)))
                pp_det = get_precprod_member( xp, t, fcsttime, member=0, lfcst=args.lfcst, verbose=True, cache=None )
            else :
                print(('reading precipitation of det member for time [ %d, %d ] min...' % (fcsttime-tresmin_sfc,fcsttime)))
                pp_det = get_precprod_member( xp, t, fcsttime-tresmin_sfc, member=0, lfcst=args.lfcst, verbose=True, cache=None )

            tp_det  = pp_det['model']
        else :
            tp_det = None


        # cosmos indices corresponding to satellite image pixels:
        cs = xp.get_cosmo( start_time, lfcst = args.lfcst, prefix='lfff', suffix='sfc', member=1, output_time=0 )
        fcilat, fcilon = cs.cosmo_indices( vens.lat, vens.lon, method='linear', variable='TOT_PREC' )
        invld = where((fcilat<0)|(fcilon<0))
        #print fcilat.shape, type(fcilat)
        cilat, cilon = array(fcilat,dtype=int), array(fcilon,dtype=int)
        #print 'cilatlonminmax ', cilat.min(), cilat.max(), cilon.min(), cilon.max()
        print('pixels outside of the COSMO-DE region : %d (%f%%)' % (len(invld[0]),100*len(invld[0])/float(vens.lat.size)))

        if not tp_det is None :
            tp_det_sat = tp_det[cilat,cilon]
            tp_det_sat.mask[invld] = True
        else :
            tp_det_sat = None


        # compute probabilities for exceeding several thresholds
        tp_thresholds = [0.1,0.5,1.0,5.0] # mm/h
        tp_probex = {}
        tp_obs_sat = {}
        tp_probex_sat = {}
        for tp_thres in tp_thresholds :
            tp_binary = tp_ens*0
            tp_binary[where(tp_ens > tp_thres)] = 1
            tp_probex[tp_thres] = tp_binary.mean(axis=0)

            # fig, ax = plt.subplots()
            # ax.imshow(tp_binary.mean(axis=0))
            # fig.savefig('tp_binary_mean.png')
            # plt.close(fig)
            #
            # fig, ax = plt.subplots()
            # ax.imshow(tp_binary.mean(axis=0)[cilat,cilon])
            # fig.savefig('tp_binary_mean_sat.png')
            # plt.close(fig)
            #
            # sys.exit()

            #print 'tp_* shapes ', tp_obs.shape,  tp_probex.shape, type(tp_obs), type(tp_probex)

            tp_obs[-1,-1] = 0
            tp_probex[tp_thres][-1,-1] = 0

            tp_obs_sat[tp_thres]    = tp_obs[cilat,cilon]
            #tp_obs_sat[tp_thres][invld] = 0
            tp_obs_sat[tp_thres].mask[invld] = True

            tp_probex_sat[tp_thres] = tp_probex[tp_thres][cilat,cilon]
            #tp_probex_sat[tp_thres][invld] = 0
            tp_probex_sat[tp_thres].mask[invld] = True
            #tp_probex_sat[tp_thres][where(tp_probex_sat[tp_thres] > 1.001)] = 0
            #print 'tp_*_sat shapes ', tp_obs_sat.shape,  tp_probex_sat.shape, type(tp_obs_sat), type(tp_probex_sat)


    # generate plots ...................................................................................................


    grid = True
    probex_cmap = probex_colormap( xp.n_ens )
    probex_inv_cmap = probex_colormap( xp.n_ens, inverse=True )


    if args.rt_input :
        iname = 'rt_input'
        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)

        fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=args.lfcst )
        pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname).replace('.001_','.mean_')+'.'+args.file_type
        ptitle = xp.settings['EXPID'] + (' tauw_mean '%tp_thres)+channel+' '+tstamp
        plot_reflectance( tp_probex_sat[tp_thres][pxil:pxir,pxjb:pxjt], ptitle, pfname,
                              lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt],
                              vmin=0.0, vmax=1.0, cmap=probex_inv_cmap,
                              infos=False, notext=False, grid=grid, contours=0,
                              cfield=tp_obs_sat[tp_thres][pxil:pxir,pxjb:pxjt], cfield_alpha=0.05, thres=tp_thres,
                              cpath=visop_assim_area )


    if args.precip :

        # precip distribution from observation and members

        for tp_thres in tp_thresholds :

            if abs(tp_thres-round(tp_thres)) < 0.1 :
                iname = 'prec_probex_%.0fmm' % tp_thres
            else :
                iname = 'prec_probex_%.1fmm' % tp_thres
            if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)

            fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=args.lfcst )
            pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname).replace('.001_','.mean_')+'.'+args.file_type
            ptitle = xp.settings['EXPID'] + (' P(precip>%.1fmm/h) '%tp_thres)+channel+' '+tstamp
            plot_reflectance( tp_probex_sat[tp_thres][pxil:pxir,pxjb:pxjt], ptitle, pfname,
                              lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt],
                              vmin=0.0, vmax=1.0, cmap=probex_inv_cmap,
                              infos=False, notext=False, grid=grid, contours=0,
                              cfield=tp_obs_sat[tp_thres][pxil:pxir,pxjb:pxjt], cfield_alpha=0.05, thres=tp_thres,
                              cpath=visop_assim_area )


    # reflectance distribtion from observation, deterministic run and members...
    iname = 'refl'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    for i in members :
        fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=i, channel=channel, lfcst=args.lfcst )
        #print 'base filename for member ', i, ' images : ', fname
        pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','')+'.'+args.file_type
        if i == -1 :
            ptitle = "obs"
        elif i == i_det :
            ptitle = xp.settings['EXPID'] + " det"
            pfname = pfname.replace('.000.','.det.')
        else :
            ptitle = xp.settings['EXPID'] + " mem. #%d"
        ptitle += ' '+channel+' '+tstamp
        print('plotting reflectance for member %d to file %s ...' % (i,pfname))
        plot_reflectance( vens[i][pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                          infos=False, notext=False, grid=grid, contours=0, cpath=visop_assim_area )
    if args.precip :
        for tp_thres in tp_thresholds :
            iname = 'refl_precip%.1fmm'%tp_thres
            if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)

            for i in members :
                fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=i, channel=channel, lfcst=args.lfcst )
                pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','')+'.'+args.file_type
                if i == -1 :
                    ptitle = "obs"
                elif i == i_det :
                    ptitle = xp.settings['EXPID'] + " det"
                    pfname = pfname.replace('.000.','.det.')
                else :
                    ptitle = xp.settings['EXPID'] + " mem. #%d"
                ptitle += ' '+channel+' '+tstamp
                print('plotting reflectance + %.2fmm precip contours for member %d to file %s ...' % (tp_thres,i,pfname))
                if i == 0 : #deterministic member
                    print( '>>>>>>> USING DETERMINISTIC TOTPREC FOR MEMBER ', i )
                    cfld = tp_det_sat[pxil:pxir,pxjb:pxjt]
                else :
                    print( '>>>>>>> USING OBSERVED TOTPREC FOR MEMBER ', i )
                    cfld = tp_obs_sat[tp_thres][pxil:pxir,pxjb:pxjt]
                plot_reflectance( vens[i][pxil:pxir,pxjb:pxjt], ptitle, pfname,
                                  lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=grid, contours=0,
                                  cfield=cfld, cfield_alpha=0.05, thres=tp_thres,
                                  cpath=visop_assim_area )

    # ...and ensemble mean
    fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=args.lfcst )
    pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname).replace('.001_','.mean_')+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' mean '+channel+' '+tstamp
    plot_reflectance( vens.mean2d()[pxil:pxir,pxjb:pxjt], ptitle, pfname,
                      lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                      infos=False, notext=False, grid=grid, contours=0,
                      cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.05, thres=0.3, cpath=visop_assim_area )

    # reflectance errors for det, ensemble members...
    iname = 'refl_error'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    for i in members[1:] :
        fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=i, channel=channel, lfcst=args.lfcst )
        #print iname +': base filename for member ', i, ' images : ', fname
        pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname)+'.'+args.file_type
        if i == -1 :
            ptitle = "obs"
        elif i == i_det :
            ptitle = xp.settings['EXPID'] + " det"
            pfname = pfname.replace('.000_','.det_')
        else :
            ptitle = xp.settings['EXPID'] + " mem. #%d"
        ptitle += ' '+channel+' '+tstamp
        if i == i_det :
            obs = vens[-1] + 0.0
            obs[ where(vens[i]<1e-6) ] = 0
        plot_reflectance( (vens[i]-obs)[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=-1.0, vmax=1.0,
                          infos=True, notext=False, grid=grid, contours=0,
                          cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.05, thres=0.3, cpath=visop_assim_area )
    # ...and ensemble mean
    fname = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=args.lfcst )
    pfname = output_path+'/'+iname+'/'+fname.split('/')[-1].replace('.npy','_'+iname).replace('.001_','.mean_')+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' mean '+channel+' '+tstamp
    plot_reflectance( (vens.mean2d()-obs)[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=-1.0, vmax=1.0,
                      infos=True, notext=False, grid=grid, contours=0,
                      cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.05, thres=0.3, cpath=visop_assim_area )

    # reflectance spread
    iname = 'spread'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' spread '+channel+' '+tstamp
    plot_reflectance( vens.spread2d()[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0, vmax=0.5,
                      infos=False, notext=False, grid=grid, contours=0, cpath=visop_assim_area )
                      #cfield=(vens.eval_region(binary=True)*1.0)[pxil:pxir,pxjb:pxjt], cfield_alpha=0.0, thres=0.5,

    # spaghetti plots
    iname = 'spag03'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' spaghetti R=0.3 '+channel+' '+tstamp
    plot_reflectance( vens[-1][pxil:pxir,pxjb:pxjt]*0+1, ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                      infos=False, notext=False, grid=grid, contours=0, spag=vens, thres=0.3, cpath=visop_assim_area )
    iname = 'spag05'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' spaghetti R=0.5 '+channel+' '+tstamp
    plot_reflectance( vens[-1][pxil:pxir,pxjb:pxjt]*0+1, ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                      infos=False, notext=False, grid=grid, contours=0, spag=vens, thres=0.5, cpath=visop_assim_area )

    # probability of cloudiness
    iname = 'probex03'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' P(R>0.3) '+channel+' '+tstamp
    plot_reflectance( vens.probex(thres=0.3)[pxil:pxir,pxjb:pxjt], ptitle, pfname,
                      lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                      infos=False, notext=False, grid=grid, contours=0,
                      cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.2, thres=0.3, cmap=probex_cmap, cpath=visop_assim_area )
    iname = 'probex05'
    if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
    pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
    ptitle = xp.settings['EXPID'] + ' P(R>0.5) '+channel+' '+tstamp
    plot_reflectance( vens.probex(thres=0.5)[pxil:pxir,pxjb:pxjt], ptitle, pfname,
                      lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                      infos=False, notext=False, grid=grid, contours=0,
                      cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.2, thres=0.5, cmap=probex_cmap, cpath=visop_assim_area )

    if args.obsloc != '' :
        for obstype in args.obsloc.split(',') :
            iname = 'obsloc'+obstype+'_probex03'
            if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
            pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
            ptitle = xp.settings['EXPID'] + ' P(R>0.3) '+channel+' '+tstamp+' + obsloc '+obstype
            if obstype in ekf :
                plot_reflectance( vens.probex(thres=0.3)[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=grid, contours=0,
                                  cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.2, thres=0.3, cmap=probex_cmap, cpath=visop_assim_area,
                                  scat_lon=ekf[obstype].obs(param='lon'), scat_lat=ekf[obstype].obs(param='lat') )
            else :
                # no obs available -- plot anyway...
                plot_reflectance( vens.probex(thres=0.3)[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=grid, contours=0,
                                  cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.2, thres=0.3, cmap=probex_cmap, cpath=visop_assim_area )

            iname = 'obsloc'+obstype+'_seviri'
            if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
            pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
            ptitle = xp.settings['EXPID'] + ' SEVIRI '+channel+' '+tstamp+' + obsloc '+obstype

            #if args.precip :
            #    tp_thres=1.0
            #    cfield=tp_obs_sat[tp_thres][pxil:pxir,pxjb:pxjt]
            #else :
            #    cfield = None
            #    tp_thres = None

            if obstype in ekf :
                plot_reflectance( vens[-1][pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=grid, contours=0, cpath=visop_assim_area,
                                  scat_lon=ekf[obstype].obs(param='lon'), scat_lat=ekf[obstype].obs(param='lat') )
            else :
                # no obs available -- plot anyway...
                plot_reflectance( vens[-1][pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                                  infos=False, notext=False, grid=grid, contours=0, cpath=visop_assim_area )

    if args.i2oloc != '' : # use specified VISOP_I2O_SETTINGS to compute observation locations
        print('PLOTTING I2O LOC for ', args.i2oloc)
        print('instead of           ', xp.settings['VISOP_I2O_SETTINGS'])
        i2o_lon = vens.i2o( 'lon', settings=args.i2oloc )
        i2o_lat = vens.i2o( 'lat', settings=args.i2oloc )
        for i in range(i2o_lon.size) :
            print('-- obs #%03d : lon = %6.2f, lat=%6.2f' % (i, i2o_lon.ravel()[i], i2o_lat.ravel()[i] ))

        # scatter plots
        scplots = [{'lat':i2o_lat.ravel(),'lon':i2o_lon.ravel(),'text':['%d'%i for i in range(i2o_lon.size)],'color':'#ff00ff'}]
        if args.obsloc != '' :
            scplots.append({'lat':ekf[obstype].obs(param='lat'),'lon':ekf[obstype].obs(param='lon'),'color':'#ffff00'})

        iname = 'i2oloc_probex03'
        if not os.path.exists(output_path+'/'+iname) : os.mkdir(output_path+'/'+iname)
        pfname = output_path+'/'+iname+'/'+base_pfname+'.'+iname+'.'+args.file_type
        ptitle = 'i2oloc '+args.i2oloc[:40]
        plot_reflectance( vens.probex(thres=0.3)[pxil:pxir,pxjb:pxjt], ptitle, pfname, lat=vens.lat[pxil:pxir,pxjb:pxjt], lon=vens.lon[pxil:pxir,pxjb:pxjt], vmin=0.0, vmax=1.0,
                          infos=False, notext=False, grid=grid, contours=0,
                          cfield=vens[-1][pxil:pxir,pxjb:pxjt], cfield_alpha=0.2, thres=0.3, cmap=probex_cmap, cpath=visop_assim_area,
                          scatter=scplots )
        #                  scat_lon=i2o_lon.ravel(), scat_lat=i2o_lat.ravel(),
        #                  scat_txt=['%d'%i for i in range(i2o_lon.size)] )

    if False :
        # bias plot
        pfname = base_pfname+'.bias.'+args.file_type
        ptitle = 'bias '+channel+' '+tstamp
        plot_reflectance( vens.bias2d(), ptitle, pfname, lat=vens.lat, lon=vens.lon, vmin=-0.5, vmax=0.5,
                          infos=False, notext=False, grid=grid, contours=0,
                          cfield=vens.eval_region(binary=True)*1.0, cfield_alpha=0.0, thres=0.5, cpath=visop_assim_area )


#-------------------------------------------------------------------------------
if __name__ == "__main__": # ---------------------------------------------------
#-------------------------------------------------------------------------------

    parser = argparse.ArgumentParser(description='Generate VISOP plots for KENDA experiment')

    parser.add_argument( '-a', '--all-members', dest='all_members',  help='generate plots for each of the members', action='store_true' )
    parser.add_argument( '-l', '--lfcst',       dest='lfcst',        help='generate images for long forecasts (not cycling results)',   action='store_true' )
    parser.add_argument( '-i', '--rt-input',    dest='rt_input',     help='plot also RT input data', action='store_true' )

    parser.add_argument( '-c', '--crop', dest='crop', help='number of pixels to crop from the left,right,bottom,top boundaries', default='' )

    parser.add_argument( '-H', '--histograms',  dest='histograms', help='plot reflectance histograms', action='store_true' )
    parser.add_argument(       '--channel',     dest='channel',    help='channel[s] (comma-separated list, deafult=VIS006)', default='VIS006' )

    parser.add_argument( '-s', '--start-time',  dest='start_time',  help='first fcst start time',    default='' )
    parser.add_argument( '-e', '--end-time',    dest='end_time',    help='last  fcst start time',     default='' )
    parser.add_argument( '-d', '--delta-time',  dest='delta_time',  help='time interval', default='' )
    parser.add_argument( '-t', '--output-times', dest='output_times', help='comma-separated list of output times [minutes]', default='' )

    parser.add_argument( '-P', '--precip',      dest='precip',      help='add precipitation information', action='store_true' )
    parser.add_argument( '-O', '--obsloc',      dest='obsloc',      help='indicate locations of observations with the specified type[s], e.g. RAD,TEMP', default='' )
    parser.add_argument(       '--i2oloc',      dest='i2oloc',      help='indicate locations of reflectance observations for the specified VISOP_I2O_SETTINGS', default='' )
    parser.add_argument( '-p', '--path',        dest='output_path', help='path to the directory in which the plots will be saved', default='auto' )
    parser.add_argument( '-f', '--filetype',    dest='file_type',   help='file type [ png (default) | pdf | eps | svg ...]', default='png' )
    parser.add_argument( '-v', '--verbose',     dest='verbose',     help='be more verbose',   action='store_true' )    

    parser.add_argument( 'logfile', metavar='logfile', help='log file name', nargs='*' )
    args = parser.parse_args()

    # process all log files

    xps = {}
    for logfile in args.logfile :

        print()
        print(("processing file %s ..." % logfile))

        xp = Experiment(logfile)
        xps[logfile] = xp
        print(('experiment %s : %s #members, first cycling fcst start time %s, last analysis time %s' % ( \
               xp.settings['exp'], xp.settings['N_ENS'], xp.fcst_start_times[0], xp.veri_times[-1] )))

        # determine time range

        if args.start_time != '' :
            start_time = args.start_time
        else :
            if args.lfcst :
                start_time = xp.lfcst_start_times[0]
            else :
                start_time = xp.fcst_start_times[0]
            print(('selecting first fcst start time = ', start_time))

        if args.end_time != '' :
            end_time = args.end_time
        else :
            if args.lfcst :
                end_time = xp.lfcst_start_times[-1]
            else :
                end_time = xp.fcst_start_times[-1]
            print(('selecting last fcst start time = ', end_time))

        if args.delta_time != '' :
            delta_time = args.delta_time
        else :
            if args.lfcst :
                delta_time = xp.lfcst_settings['FCINT']
            else :
                delta_time = xp.settings['ASSINT']
        times = time_range( start_time, end_time, delta_time  )
        print(('fcst start times: ', times))

        if args.output_times == '' :
            if args.lfcst :
                fcsttimes = xp.lfcst_visop_output_times_min
            else :
                fcsttimes = xp.visop_output_times_min
        else :
            fcsttimes = args.output_times.split(',')
        print(('visop output times [min]: ', fcsttimes))

        # loop over channels and times, read data and generate plots
        for channel in args.channel.split(',') :
            for t in times :
                for fcsttime in fcsttimes :
                    t_abs = Time14(t) + Time14(fcsttime*60)
                    h = t_abs.hour()
                    m = t_abs.minute()
                    if (h > int(xp.settings['VISOP_START_HOUR'])) or ((h == int(xp.settings['VISOP_START_HOUR'])) and (m >= int(xp.settings['VISOP_START_MINUTE']))) :
                        if (h < int(xp.settings['VISOP_STOP_HOUR'])) or ((h == int(xp.settings['VISOP_STOP_HOUR'])) and (m <= int(xp.settings['VISOP_STOP_MINUTE']))) :
                            plot_images( xp, t, fcsttime, args )

    # end of logfile loop ..........................................................................

