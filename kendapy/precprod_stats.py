#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . P R E C P R O D _ S T A T S
#  generate precipitation product statsitics for ensemble forecasts generated by KENDA
#
#  2018.1 L.Scheck

from __future__ import absolute_import, division, print_function
# import matplotlib/pylab such that it does not require a X11 connection
import matplotlib
matplotlib.use('Agg') 
import pylab as plt
#from mpl_toolkits.basemap import Basemap, cm
import matplotlib.gridspec as gridspec

import sys, os, argparse
import pickle as pickle
from numpy import *
import numpy.ma as ma
from kendapy.experiment import Experiment
from kendapy.time14 import Time14, time_range
from kendapy.binplot import binplot
#from visop_i2o_em import area_settings

from kendapy.precprod_read import read_product
from kendapy.precprod_ens import get_precprod_ens
from kendapy.cosmo_state import cosmo_grid
from kendapy.score_brier import brier_score, brier_score_masked
from skimage.measure import block_reduce

#--------------------------------------------------------------------------------
def get_precprod_lfcst_stats( xp_, times=None, cache=True, recompute=True, verbose=False ) :
    """Retrieve precipitation data from (long, not cycling) ensemble forecasts started at the specified times and compute basic statistics"""

    pfs_version = 'V0.1' # change this to mark cache files as deprecated

    imin = 80
    imax = imin+255
    jmin = 145
    jmax = jmin+255

    if isinstance(xp_, str) : # xp_ is a path
        xp = Experiment(xp_)
    else :                           # xp_ is a Experiment object
        xp = xp_

    if verbose : print('experiment %s : %s #members, first fcst start time %s, last analysis time %s' % ( \
                       xp.settings['exp'], xp.settings['N_ENS'], xp.fcst_start_times[0], xp.veri_times[-1] ))

    # determine time range
    if times is None :
        times = xp.lfcst_start_times

    tresmin = xp.lfcst_sfc_output_times_min[1] - xp.lfcst_sfc_output_times_min[0]

    if verbose :
        print('lfcst start times: ', times)
        print('sfc output is available at minutes ',  xp.lfcst_sfc_output_times_min)
        print('--> time resolution is %d minutes...' % tresmin)

    # multiscale analysis
    #scales = map( int, xp.settings['VISOP_EVAL_SCALES'].split(',') )   #[1,2,4,8,16,32,64]
    scales = [1,2,4,8,16,32,64]

    # return value
    rs = None

    if cache :
        # construct cache file name
        cachefpath = xp.settings['PLOT_DIR'] + '/cache/precprod_lfcst_stats/'
        if not os.path.exists(cachefpath) :
            os.system('mkdir -p '+cachefpath)

        # construct cache file name
        cachefname = 'PFS_%s_%s-%s.pickle' % (pfs_version,times[0],times[-1])

        if os.path.exists(cachefpath+cachefname) and not recompute :
            print('loading %s%s ...' % (cachefpath,cachefname))
            with open( cachefpath+cachefname, 'rb') as f :
                rs = pickle.load(f)
        else :
            if recompute :
                print('ignoring existing cache file %s%s ...' % (cachefpath,cachefname))
            else :
                print('cache file %s%s does not yet exist...' % (cachefpath,cachefname))

    lat, lon = cosmo_grid()

    if rs is None :
        stats = {}
        clc   = {}
        mstat = {'scales':scales}

        pp_cache = {}

        # loop over start times of long forecasts
        for tstart in times :

            print('forecast started at ', tstart)

            tp_prev = None

            # loop over output times
            #for tfcst in xp.lfcst_sfc_output_times_min[:-1] :
            for itprec in range(len(xp.lfcst_sfc_output_times_min)-1) :

                tprec_start = xp.lfcst_sfc_output_times_min[itprec]
                tprec_end   = xp.lfcst_sfc_output_times_min[itprec+1]
                tabs = str(Time14(tstart)+Time14(tprec_start*60))
                pp = get_precprod_ens( xp, tstart, tprec_start, lfcst=True, verbose=True, cache=pp_cache )
                tp, tp_obs = pp['ens'], pp['obs']

                tp_mean = tp.mean(axis=0)           # ensemble mean field

                print(("%s, minutes %3d-%3d : " % (tstart, tprec_start, tprec_end)), tp_mean.mean(), tp_obs.mean(), tp_mean.shape, tp_obs.shape, lat.shape, lon.shape, lat.mean())

                bs = []
                for s in scales :
                    thres = 0.1 # mm
                    obs = block_reduce( tp_obs[imin:imax+1,jmin:jmax+1], (s,s), func=mean )
                    ens = block_reduce( tp[:,imin:imax+1,jmin:jmax+1], (1,s,s), func=mean )
                    bs.append( brier_score_masked( obs, ens, thres, components=True ) )
                    print("    ", s, bs[-1]['bss'])


                if True :

                    from matplotlib import pyplot as plt
                    from mpl_toolkits.axes_grid1 import make_axes_locatable
                    fig, ax = plt.subplots( 2, 2, figsize=(12,12) ) #sharey=True,

                    #xp.settings['VISOP_EVAL_AREA']

                    im = ax[0,0].imshow( tp[0,:,:], origin='lower',  vmin=0, vmax=20, cmap=plt.get_cmap('ocean_r') )
                    divider = make_axes_locatable(ax[0,0])
                    cax = divider.append_axes("right", size="5%", pad=0.05)
                    plt.colorbar(im, cax=cax)
                    ax[0,0].contour( lat, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[0,0].contour( lon, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[0,0].plot( [imin,imax,imax,imin,imin], [jmin,jmin,jmax,jmax,jmin], 'b' )
                    cs = ax[0,0].contour( lat, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[0,0].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    cs = ax[0,0].contour( lon, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[0,0].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    ax[0,0].text( 10, 10, 'mem. 0, mean=%f, max=%f' % (tp[0,:,:].mean(),tp[0,:,:].max()) )

                    im = ax[1,0].imshow( tp_obs, origin='lower', vmin=0, vmax=20, cmap=plt.get_cmap('ocean_r') )
                    divider = make_axes_locatable(ax[1,0])
                    cax = divider.append_axes("right", size="5%", pad=0.05)
                    plt.colorbar(im, cax=cax)
                    ax[1,0].contour( lat, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[1,0].contour( lon, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[1,0].plot( [imin,imax,imax,imin,imin], [jmin,jmin,jmax,jmax,jmin], 'b' )
                    cs = ax[1,0].contour( lat, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[1,0].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    cs = ax[1,0].contour( lon, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[1,0].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    ax[1,0].text( 10, 10, 'obs, mean=%f, max=%f' % (tp_obs.mean(),tp_obs.max()) )

                    im = ax[0,1].imshow( tp_mean, origin='lower',  vmin=0, vmax=20, cmap=plt.get_cmap('ocean_r') )
                    divider = make_axes_locatable(ax[0,1])
                    cax = divider.append_axes("right", size="5%", pad=0.05)
                    plt.colorbar(im, cax=cax)
                    ax[0,1].contour( lat, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[0,1].contour( lon, levels=arange(0,90,1), colors='#cccccc', linewidths=0.3 )
                    ax[0,1].plot( [imin,imax,imax,imin,imin], [jmin,jmin,jmax,jmax,jmin], 'b' )
                    ax[0,1].contour( tp_obs, levels=[1.0], colors='r', linewidths=0.5 )
                    cs = ax[0,1].contour( lat, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[0,1].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    cs = ax[0,1].contour( lon, levels=arange(0,90,5), colors='k', linewidths=0.5 )
                    ax[0,1].clabel( cs, cs.levels, fmt="%4.0f", inline=True, fontsize=10 )
                    ax[0,1].text( 10, 10, 'ens. mean, mean=%f, max=%f' % (tp_mean.mean(),tp_mean.max()) )

                    #plt.colorbar()
                    tpbins = arange(0.5,20.1,0.5)

                    for m in range(1,xp.n_ens) :
                        tp_mem_hist, tpedges = histogram( tp[m,:,:], tpbins )
                        ax[1,1].semilogy( tpbins[:-1], tp_mem_hist, '#cccccc' )

                    tp_mean_hist, tpedges = histogram( tp_mean, tpbins )
                    ax[1,1].semilogy( tpbins[:-1], tp_mean_hist, 'r', label='ens. mean' )

                    tp_mem0_hist, tpedges = histogram( tp[0,:,:], tpbins )
                    ax[1,1].semilogy( tpbins[:-1], tp_mem0_hist, 'b', label='mem. 0' )

                    tp_obs_hist, tpedges = histogram( tp_obs, tpbins )
                    ax[1,1].semilogy( tpbins[:-1], tp_obs_hist,  'k', label='obs' )

                    ax[1,1].legend(title='%s bs=%f'%(xp.settings['EXPID'],bs[4]['bss']))
                    plt.savefig(tabs+'.png')
                    plt.close(fig)


        sys.exit(-1)

        if False :
            stats[t] = {}
            clc[t]   = {}
            mstat[t] = {}
            for fcsttime in fcsttimes :

                # gather data from cycling forecasts .....................................................

                fname0 = xp.visop_filename( t, fcsttime=fcsttime, memidx=0, channel=channel )
                if not os.path.exists(fname0) :
                    print('does not exist : ', fname0)
                    continue
                #base_pfname = fname0.split('/')[-1].replace('.000.npy','')

                print('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime))
                vens = xp.get_visop( t, fcsttime=fcsttime, channel=channel )
                #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                if error_evolution :
                    stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=xp.settings['VISOP_I2O_SETTINGS']),
                                           'spread': vens.i2o('spread', settings=xp.settings['VISOP_I2O_SETTINGS']),
                                           'rmse':   vens.i2o('rmse',   settings=xp.settings['VISOP_I2O_SETTINGS']) }
                    print('stats : ', stats[t][fcsttime])

                if multiscale :
                    mstat[t][fcsttime] = {}
                    for s in scales :
                        #settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                        settings = 'SUPEROBB:%d,%d_%s' % (2*s,s,xp.settings['VISOP_EVAL_AREA'])
                        mstat[t][fcsttime][s] = { 'settings':settings,
                                                  'bias':   vens.i2o('bias',   settings=settings),
                                                  'spread': vens.i2o('spread', settings=settings),
                                                  'rmse':   vens.i2o('rmse',   settings=settings) }
                        if True : # do it for all members
                            for m in range(1,xp.n_ens+1) :
                                mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                        #print ('scale %02d : '%s), mstat[t][fcsttime][s]

                if clc_evolution :
                    # extract area information, get rid of all transformations (superobbing etc.)
                    area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                    clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                         'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                         'det30':    vens.i2o('clc30_det',    settings=area),
                                         'obs60':    vens.i2o('clc60_obs',    settings=area),
                                         'ensmean60':vens.i2o('clc60_ensmean',settings=area),
                                         'det60':    vens.i2o('clc60_det',    settings=area) }
            # end of visop output times
        # end of fcst start times

        # gather data from long forecasts .....................................................
        if lfcst :
            print()
            print('Gathering data from long forecasts...')
            lfcst_stats = {}
            lfcst_clc   = {}
            lfcst_mstat = {'scales':scales}
            for t in times :
                print('time ', t, end=' ')
                if t in xp.lfcst_start_times :
                    print('is relevant')
                    lfcst_stats[t] = {}
                    lfcst_clc[t]   = {}
                    lfcst_mstat[t] = {}
                    for fcsttime in xp.lfcst_visop_output_times_min :
                        fname1 = xp.visop_filename( t, fcsttime=fcsttime, memidx=1, channel=channel, lfcst=True )
                        if not os.path.exists(fname1) :
                            print('does not exist : ', fname1)
                            continue
                        #base_pfname = fname1.split('/')[-1].replace('.001.npy','')

                        print('reading visop ensemble for channel %s at time %s + %dmin...' % (channel,t,fcsttime))
                        vens = xp.get_visop( t, fcsttime=fcsttime, channel=channel, lfcst=True )
                        #print 'mean ensemble mean reflectance = ', vens.mean2d().mean()

                        if error_evolution :
                            lfcst_stats[t][fcsttime] = { 'bias':   vens.i2o('bias',   settings=xp.settings['VISOP_I2O_SETTINGS']),
                                                         'spread': vens.i2o('spread', settings=xp.settings['VISOP_I2O_SETTINGS']),
                                                         'rmse':   vens.i2o('rmse',   settings=xp.settings['VISOP_I2O_SETTINGS']) }
                            print('stats : ', lfcst_stats[t][fcsttime])

                        if multiscale :
                            lfcst_mstat[t][fcsttime] = {}
                            for s in scales :
                                #settings = 'SUPEROBB:%d,%d_LATLON:74,77,329,204_LATLONUNITS:PX' % (2*s,s)
                                settings = 'SUPEROBB:%d,%d_%s' % (2*s,s,xp.settings['VISOP_EVAL_AREA'])
                                lfcst_mstat[t][fcsttime][s] = { 'settings':settings,
                                                          'bias':   vens.i2o('bias',   settings=settings),
                                                          'spread': vens.i2o('spread', settings=settings),
                                                          'rmse':   vens.i2o('rmse',   settings=settings) }
                                if True : # do it for all members
                                    for m in range(1,xp.n_ens+1) :
                                        lfcst_mstat[t][fcsttime][s]['rmse_mem%03d'%m] = vens.i2o('rmse_mem%03d'%m,settings=settings)
                                        lfcst_mstat[t][fcsttime][s]['bias_mem%03d'%m] = vens.i2o('bias_mem%03d'%m,settings=settings)
                                #print ('scale %02d : '%s), mstat[t][fcsttime][s]

                        if clc_evolution :
                            # extract area information, get rid of all transformations (superobbing etc.)
                            area = area_settings( xp.settings['VISOP_I2O_SETTINGS'] )
                            lfcst_clc[t][fcsttime] = { 'obs30':    vens.i2o('clc30_obs',    settings=area),
                                                       'det30':    vens.i2o('clc30_001',    settings=area),
                                                       'ensmean30':vens.i2o('clc30_ensmean',settings=area),
                                                       'obs60':    vens.i2o('clc60_obs',    settings=area),
                                                       'det60':    vens.i2o('clc60_001',    settings=area),
                                                       'ensmean60':vens.i2o('clc60_ensmean',settings=area) }
                            print('>>> lfcst_clc ', lfcst_clc[t][fcsttime])

                    # end of visop output times
            # end of fcst start times
        # end of long forecasts .....................................................................

        rs = {'times':times}
        if error_evolution : rs['stats'] = stats
        if clc_evolution   : rs['clc']   = clc
        if multiscale      : rs['mstat'] = mstat
        if lfcst :
            if error_evolution : rs['lfcst_stats'] = lfcst_stats
            if clc_evolution   : rs['lfcst_clc']   = lfcst_clc
            if multiscale      : rs['lfcst_mstat'] = lfcst_mstat

        if cache :
            print('saving cache file to %s%s ...' % (cachefpath,cachefname))
            with open( cachefpath+cachefname, 'wb') as f :
                pickle.dump( rs, f, pickle.HIGHEST_PROTOCOL )

    return rs

#-------------------------------------------------------------------------------
if __name__ == "__main__": # ---------------------------------------------------
#-------------------------------------------------------------------------------

    rs = get_precprod_lfcst_stats( sys.argv[1], verbose=True )
    #print
    #print 'Available data:'
    #stats = rs['stats']
    #lfcst_stats = rs['lfcst_stats']
    #for t in sorted(stats.keys()) :
    #    print '> ', t, stats[t].keys()
    #    if t in lfcst_stats :
    #        print '  --> LFCST ', sorted(lfcst_stats[t].keys())
