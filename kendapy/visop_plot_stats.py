#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  K E N D A P Y . V I S O P _ P L O T _ S T A T S
#  plot statistics for VISOP results generated by KENDA experiments
#
#  2017.3 L.Scheck 

from __future__ import absolute_import, division, print_function
# import matplotlib/pylab such that it does not require a X11 connection
import matplotlib
matplotlib.use('Agg') 
from matplotlib import pyplot as plt

import sys, os, argparse, pickle
from numpy import *
from kendapy.experiment import Experiment
from kendapy.time14 import Time14, time_range
from kendapy.colseq import colseq
from kendapy.visop_fcst import get_visop_fcst_stats


#-------------------------------------------------------------------------------
def error_evo_plot( xp, times, stats, lfcst_stats, titlestr='', ekf=True, verbose=True,
                    start_plot=True, finish_plot=True, color='k', style='', name=None, file_type='png' ) :

    if start_plot and finish_plot :
        comparison = False
    else :
        comparison = True

    cycavg = False # plot values averaged over cycles?

    if comparison :
        colrmse        = color
        colrmse_dots   = color
        colbias        = color
        colbias_dots   = color
        collfcst       = color
        colspread      = None
        colspread_dots = None

        rmse_label = xp.settings['EXPID'] if name is None else name
        spread_label=None
        bias_label=None

    else :
        colrmse        = '#000000'
        colrmse_dots   = 'b'
        colbias        = '#999999'
        colbias_dots   = '#ee9900'
        collfcst       = '#ee6699'
        colspread      = '#999999'
        colspread_dots = '#00ee99'

        rmse_label='RMSE'
        spread_label='spread'
        bias_label='bias'

        if 'talk' in style :
            colspread_dots = None
            colbias_dots   = '#ee0099'
        if 'nodots' in style :
            colspread_dots = None
            colbias_dots   = None
            colrmse_dots   = None

    if ekf :
        # get data from ekfRAD files
        ekfevo = xp.compute_error_evolution( times, obs_types=['RAD'], variables=['REFL'], state_filter='valid' )['RAD']['REFL']
        #        {'RAD': {'REFL': {'20160605100000': {'fgmean': {'bias': -0.0030769857, 'rmse': 0.08585836}, 'fgspread': {'mean': 0.10906658}...

    if start_plot :
        plt.figure(1,figsize=(10,5))
        plt.clf()

    hmin = Time14(times[0]).dayhour()
    h = hmin
    add_label=True
    for i, t in enumerate(times) :

        if verbose :
            print(('error_evo_plot: processing fcst start time #%d = %s' % ( i, t )))
            #print '                available fcst times: ', sorted(stats[t].keys())
            #print '                visop output is available at ', h+xp.visop_fcsttimes()/60.0

        plt.figure(1)

        if not lfcst_stats is None :
            if t in lfcst_stats :
                #print lfcst_stats[t]
                lfcst_t_min = sorted(lfcst_stats[t].keys())
                lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                #print lfcst_t_hour
                plt.plot( lfcst_t_hour, [ lfcst_stats[t][f]['rmse'] for f in lfcst_t_min ], '-', color=collfcst, linewidth=3 )
                plt.plot( lfcst_t_hour, [ lfcst_stats[t][f]['bias'] for f in lfcst_t_min ], '-', color=collfcst, linewidth=1 )

        if len(xp.visop_fcsttimes()) == len(list(stats[t].keys())) :
            if not colrmse is None :
                plt.plot( h+xp.visop_fcsttimes()/60.0, [ stats[t][f]['rmse']   for f in sorted(stats[t].keys()) ], '.-', color=colrmse, linewidth=1.5,  label=rmse_label   if add_label else None  )
            if not colspread is None :
                plt.plot( h+xp.visop_fcsttimes()/60.0, [ stats[t][f]['spread'] for f in sorted(stats[t].keys()) ], '--', color=colspread, label=spread_label if add_label else None  )
            if not colbias is None :
                plt.plot( h+xp.visop_fcsttimes()/60.0, [ stats[t][f]['bias']   for f in sorted(stats[t].keys()) ], '.-', color=colbias, linewidth=0.5,  label=bias_label   if add_label else None  )
        else :
            print(('error_evo_plot : data missing for t=%s...', t))

        if ekf :
            if cycavg :
                fgmean = sqrt((array([ stats[t][f]['rmse'] for f in sorted(stats[t].keys())[1:] ])**2).mean())
                plt.plot( (h+xp.visop_fcsttimes()[1]/60.0,h+xp.visop_fcsttimes()[-1]/60.0), (fgmean,fgmean), 'r' )

            # EKF values: correspond to mean values in the interval ]t,t+ASSINT]
            if i < len(times)-1 and times[i+1] in ekfevo :
                if cycavg :
                    # EKF values averaged over assimilation window
                    plt.scatter( h+xp.visop_fcsttimes()[1:].mean()/60.0, ekfevo[times[i+1]]['fgmean']['rmse'], marker='x', color='r' )
                    plt.scatter( h+xp.visop_fcsttimes()[1:].mean()/60.0, ekfevo[times[i+1]]['anamean']['rmse'], marker='o', color='r' )
                    plt.plot( (h+xp.visop_fcsttimes()[1]/60.0,h+xp.visop_fcsttimes()[-1]/60.0), (ekfevo[times[i+1]]['anamean']['rmse'],ekfevo[times[i+1]]['anamean']['rmse']), color='r' )

                #plt.scatter( h+xp.visop_fcsttimes()[1:].mean()/60.0, ekfevo[times[i+1]]['fgens']['spread'], marker='x', color=colspread )
                #plt.scatter( h+xp.visop_fcsttimes()[1:].mean()/60.0, ekfevo[times[i+1]]['anaens']['spread'], marker='o', color=colspread )

                # EKF values at analysis times
                ms = 30
                if not colrmse_dots is None :
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['fgmean']['rmse_last'],   s=ms, marker='x', color=colrmse_dots )
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['anamean']['rmse_last'],  s=ms, marker='o', color=colrmse_dots )
                    plt.scatter( h+xp.visop_fcsttimes()[0]/60.0, stats[t][sorted(stats[t].keys())[0]]['rmse'], s=ms, marker='s', color=colrmse_dots )
                    #plt.gca().arrow( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['fgmean']['rmse_last'],
                    #                 0, ekfevo[times[i+1]]['anamean']['rmse_last'] - ekfevo[times[i+1]]['fgmean']['rmse_last'],
                    #                 color=colrmse_dots, length_includes_head=True, width=0.001, head_width=0.01)

                if not colbias_dots is None :
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['fgmean']['bias_last'],   s=ms, marker='x', color=colbias_dots )
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['anamean']['bias_last'],  s=ms, marker='o', color=colbias_dots )
                    plt.scatter( h+xp.visop_fcsttimes()[0]/60.0, stats[t][sorted(stats[t].keys())[0]]['bias'], s=ms, marker='s', color=colbias_dots )
                    #plt.gca().arrow( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['fgmean']['bias_last'],
                    #                 0, ekfevo[times[i+1]]['anamean']['bias_last'] - ekfevo[times[i+1]]['fgmean']['bias_last'],
                    #                 color=colbias_dots, length_includes_head=True, width=0.001, head_width=0.01)

                if not colspread_dots is None :
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['fgens']['spread_last'],  s=ms, marker='x', color=colspread_dots )
                    plt.scatter( h+xp.visop_fcsttimes()[-1]/60.0, ekfevo[times[i+1]]['anaens']['spread_last'], s=ms, marker='o', color=colspread_dots )

        add_label=False
        h += float(xp.settings['ASSINT'])/3600.0
    hmax = h
    hdur = hmax-hmin
    pltrng = (hmin-0.05*hdur,hmax+0.05*hdur)

    if finish_plot :
        plt.figure(1)
        plt.plot( pltrng, (0,0), '-.k', linewidth=0.3 )
        plt.ylim((-0.05,0.25))
        plt.xlim(pltrng)
        plt.xlabel('t [h] UTC')
        plt.ylabel('reflectance bias / spread / rmse')
        plt.legend(frameon=False)
        plt.title(titlestr)
        plt.grid()
        plt.savefig('error_evo_'+('lfcst_' if args.lfcst else '') \
                                +('noekf_' if args.no_ekf else '') \
                                +(style+'_' if style != '' else '') \
                                +channel+'_i2o-'+args.i2o_settings+'.'+file_type)

#-------------------------------------------------------------------------------
def fss_evo_plot( xp, times, rs, lfcst=False, titlestr='', args=None, figsize=(10,5) ) :

    scales = rs['fss_windows']
    stat = rs['stats']
    lfcst_stat = rs['lfcst_stats']

    for refl_thres in rs['refl_thresholds'] :

        fig, ax = plt.subplots( 1, 1, figsize=figsize )
        hmin = Time14(times[0]).dayhour()
        h = hmin
        add_label=True
        add_label_lfcst=True
        found_lfcst=False
        for i, t in enumerate(times) :
            for iscl, s in enumerate(scales) :
                km = s*6

                if lfcst :
                    col_lfcst = colseq( iscl, len(scales) )
                    lw  = 1
                    col = '#999999'
                    add_label = False
                else :
                    col = colseq( iscl, len(scales) )
                    lw = 2

                if not args.no_cycle :
                    #print 'DADADA', t, iscl
                    #for f in sorted(stat[t].keys()) :
                        #print 'DA---> ', iscl, f, refl_thres, stat[t][f]['fss%.2f'%refl_thres]['fss'] #[iscl]
                        #print sorted(stat[t].keys())
                        #print stat[t].keys()
                        #print stat[t][sorted(stat[t].keys())[0]].keys()
                        #print stat[t][sorted(stat[t].keys())[0]]['fss%.2f'%refl_thres].keys()
                        #print stat[t][sorted(stat[t].keys())[0]]['fss%.2f'%refl_thres]['fss']
                        #print stat[t][sorted(stat[t].keys())[0]]['fss%.2f'%refl_thres]['fss'][0,iscl]
                        #print [ stat[t][f]['fss%.2f'%refl_thres]['fss'][0,iscl] for f in sorted(stat[t].keys()) ]
                    if iscl == 0 :
                        plt.plot( h+xp.visop_fcsttimes()/60.0, [ stat[t][f]['fss%.2f'%refl_thres]['fss_random'] for f in sorted(stat[t].keys()) ],
                              ':', color='k', label='random' if add_label else None, linewidth=lw, zorder=1 )
                        plt.plot( h+xp.visop_fcsttimes()/60.0, [ stat[t][f]['fss%.2f'%refl_thres]['fss_target'] for f in sorted(stat[t].keys()) ],
                              '--', color='k', label='target' if add_label else None, linewidth=lw, zorder=1 )
                    plt.plot( h+xp.visop_fcsttimes()/60.0, [ stat[t][f]['fss%.2f'%refl_thres]['fss'][0,iscl] for f in sorted(stat[t].keys()) ],
                              color=col, label='%dkm'%km if add_label else None, linewidth=lw, zorder=1 )

                if lfcst :
                    if t in lfcst_stat :
                        lfcst_t_min = sorted(lfcst_stat[t].keys())
                        lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                        plt.plot( lfcst_t_hour, [ lfcst_stat[t][f]['fss%.2f'%refl_thres]['fss'][0,iscl] for f in lfcst_t_min ],
                                  color=col_lfcst, linewidth=2, label='%dkm'%km if add_label_lfcst else None, zorder=2)
                        found_lfcst = True

            add_label = False
            if found_lfcst :
                add_label_lfcst = False
            h += float(xp.settings['ASSINT'])/3600.0
        hmax = h+3
        plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
        plt.ylim((0.0,1.0))
        plt.legend(loc='upper right', frameon=False)
        plt.xlabel('t [h UTC]')
        plt.ylabel('FSS[thres=%.2f]'%refl_thres)
        plt.title(titlestr)
        plt.grid()
        plt.savefig( 'multiscale_fss%.2f%s_evo_%s.png'%(refl_thres, '_lfcst' if lfcst else '', channel),
                     bbox_inches='tight' )


#-------------------------------------------------------------------------------
def clc_evo_plot( xp, times, clc, lfcst_clc, titlestr='' ) :

    plt.figure(1,figsize=(10,5))
    plt.clf()
    hmin = Time14(times[0]).dayhour()
    h = hmin
    add_label=True
    for i, t in enumerate(times) :
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['ensmean30'] for f in sorted(clc[t].keys()) ], 'k',               label='ensmean' if add_label else None  )
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['det30']     for f in sorted(clc[t].keys()) ], color='#999999',   label='det'     if add_label else None  )
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['obs30']     for f in sorted(clc[t].keys()) ], 'k',  linewidth=2, label='obs'     if add_label else None )
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['ensmean60'] for f in sorted(clc[t].keys()) ], 'k' )
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['det60']     for f in sorted(clc[t].keys()) ], color='#999999' )
        plt.plot( h+xp.visop_fcsttimes()/60.0, [ clc[t][f]['obs60']     for f in sorted(clc[t].keys()) ], 'k',  linewidth=2 )

        if not lfcst_clc is None :
            if t in lfcst_clc :
                lfcst_t_min = sorted(lfcst_clc[t].keys())
                lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['ensmean30'] for f in lfcst_t_min ], ':', color='#990099' )
                plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['ensmean60'] for f in lfcst_t_min ], ':', color='#cc00cc' )
                plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['det30'] for f in lfcst_t_min ], color='#990099' )
                plt.plot( lfcst_t_hour, [ lfcst_clc[t][f]['det60'] for f in lfcst_t_min ], color='#cc00cc' )

        add_label=False
        h += float(xp.settings['ASSINT'])/3600.0
    hmax = h
    plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
    plt.ylim((0,1))
    plt.legend(loc='upper right',title='domain cloud cover', frameon=False)
    plt.xlabel('t [h UTC]')
    plt.ylabel('cloud dover')
    plt.title(titlestr)
    plt.savefig('clc_evo_'+channel+'.png')


#-------------------------------------------------------------------------------
def multiscale_evo_plot( xp, times, mstat, lfcst_mstat, titlestr='', verbose=True, figsize=(10,5) ) :

    #import colorsys
    scales = mstat['scales']

    # evolution of rmse and drmse/dt of the ensemble mean for all scales
    plt.figure(1,figsize=(10,5))
    plt.clf()
    plt.figure(2,figsize=(10,5))
    plt.clf()

    hmin = Time14(times[0]).dayhour()
    h = hmin
    add_label=True
    add_label_lfcst=True
    for i, t in enumerate(times) :
        for iscl, s in enumerate(scales) :
            #hue = float(iscl)/len(scales)
            #col = colorsys.hls_to_rgb( hue, 0.6-0.2*exp(-((hue-0.35)/0.1)**2), 0.7 )
            col = colseq( iscl, len(scales) )
            km = s*6

            plt.figure(1)
            if not lfcst_mstat is None :
                if t in lfcst_mstat :
                    lfcst_t_min = sorted(lfcst_mstat[t].keys())
                    lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                    plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse'] for f in lfcst_t_min ],
                              color=col, linewidth=3, label='%dkm'%km if add_label_lfcst else None, zorder=2)
                    #plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse'] for f in lfcst_t_min ], '--', color=col )
                    if s == scales[-1] :
                        add_label_lfcst=False

                col='#cccccc'
                add_label = False

            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ],
                      color=col, label='%dkm'%km if add_label else None, linewidth=2, zorder=1 )

            plt.figure(2)
            rmses = [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ]
            drmse = rmses[-1]-rmses[-2]
            dt    = (xp.visop_fcsttimes()[-1]-xp.visop_fcsttimes()[-2])/60.0
            plt.plot( (h+xp.visop_fcsttimes()[-2]/60.0,h+xp.visop_fcsttimes()[-1]/60.0), [drmse/dt,drmse/dt],
                      color=col, label='%dkm'%km if add_label else None, linewidth=2 )

        add_label=False
        h += float(xp.settings['ASSINT'])/3600.0
    hmax = h+3


    plt.figure(1)
    plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
    plt.ylim((0,0.22))
    plt.xlim((hmin,hmax))
    plt.legend(loc='upper right', frameon=False)
    plt.xlabel('t [h UTC]')
    plt.ylabel('rmse')
    plt.title(titlestr)
    plt.grid()
    if lfcst_mstat is None :
        plt.savefig('multiscale_rmse_evo_'+channel+'.png', bbox_inches='tight')
    else :
        plt.savefig('multiscale_rmse_evo_lfcst_'+channel+'.png', bbox_inches='tight')

    plt.figure(2)
    plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
    plt.ylim((-0.05,0.1))
    plt.legend(loc='upper right', frameon=False)
    plt.xlabel('t [h UTC]')
    plt.ylabel('drmse/dt')
    plt.title(titlestr)
    plt.grid()
    plt.savefig('multiscale_drmse_dt_evo_'+channel+'.png')


    # Brier skill scores (relative to climatology) for different thresholds and scales
    for refl_thres in mstat['refl_thresholds'] :
        fig, ax = plt.subplots( 1, 1, figsize=figsize )
        hmin = Time14(times[0]).dayhour()
        h = hmin
        add_label=True
        add_label_lfcst=True
        found_lfcst=False
        for i, t in enumerate(times) :
            for iscl, s in enumerate(scales) :
                km = s*6

                if not lfcst_mstat is None :
                    col_lfcst = colseq( iscl, len(scales) )
                    lw  = 1
                    col = '#999999'
                    add_label = False
                else :
                    col = colseq( iscl, len(scales) )
                    lw = 2

                if not args.no_cycle :
                    plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['brier%.2f'%refl_thres]['bss'] for f in sorted(mstat[t].keys()) ],
                              color=col, label='%dkm'%km if add_label else None, linewidth=lw, zorder=1 )

                if not lfcst_mstat is None :
                    if t in lfcst_mstat :
                        lfcst_t_min = sorted(lfcst_mstat[t].keys())
                        lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                        plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['brier%.2f'%refl_thres]['bss'] for f in lfcst_t_min ],
                                  color=col_lfcst, linewidth=2, label='%dkm'%km if add_label_lfcst else None, zorder=2)
                        found_lfcst = True

            add_label = False
            if found_lfcst :
                add_label_lfcst = False
            h += float(xp.settings['ASSINT'])/3600.0
        hmax = h+3
        plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
        plt.ylim((-0.3,1.0))
        plt.legend(loc='upper right', frameon=False)
        plt.xlabel('t [h UTC]')
        plt.ylabel('BSS[thres=%.2f]'%refl_thres)
        plt.title(titlestr)
        plt.grid()
        plt.savefig( 'multiscale_brier%.2f%s_evo_%s.png'%(refl_thres, '' if lfcst_mstat is None else '_lfcst', channel) )

    # rmse evolution of all ensemble member (indiv. plot for each scale)
    plt.figure(1,figsize=(10,5))
    for iscl, s in enumerate(scales) :
        km = s*6
        plt.clf()
        h = hmin
        add_label=True
        for i, t in enumerate(times) :
            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['spread'] for f in sorted(mstat[t].keys()) ],
                      '--', color='#999999', label='spread' if add_label else None, linewidth=2 )

            for m in range(1,xp.n_ens+1) :
                plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['rmse_mem%03d'%m] for f in sorted(mstat[t].keys()) ],
                          color='#000000', alpha=0.2, linewidth=1,
                          label='rmse members' if (add_label and m==1) else None )

            if not lfcst_mstat is None :
                if t in lfcst_mstat :
                    lfcst_t_min = sorted(lfcst_mstat[t].keys())
                    lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                    for m in range(1,xp.n_ens+1) :
                        plt.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse_mem%03d'%m] for f in lfcst_t_min ], color='#0066cc', alpha=0.2 )

            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ],
                      color='r', label='rmse mean' if add_label else None, linewidth=2 )
            add_label=False
            h += float(xp.settings['ASSINT'])/3600.0

        plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
        plt.ylim((0,0.3))
        plt.legend(loc='upper right', frameon=False)
        plt.xlabel('t [h UTC]')
        plt.ylabel('rmse')
        plt.title(titlestr + (" scale %dkm"%km))
        plt.grid()
        plt.savefig('multiscale_rmse_s%02d_evo_%s.png' % (s,channel))

    for iscl, s in enumerate([scales[0]]) : # bias is scale-independent...
        km = s*6
        plt.clf()
        h = hmin
        add_label=True
        for i, t in enumerate(times) :
            for m in range(1,xp.n_ens+1) :
                plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['bias_mem%03d'%m] for f in sorted(mstat[t].keys()) ],
                          color='#000000', alpha=0.2, linewidth=1 )
            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['bias'] for f in sorted(mstat[t].keys()) ],
                      color='k', label='%dkm'%km if add_label else None, linewidth=2 )
            add_label=False
            h += float(xp.settings['ASSINT'])/3600.0

        plt.plot( (hmin,hmax), (0,0), '-.k', linewidth=0.3 )
        #plt.ylim((0,0.22))
        plt.legend(loc='upper right', frameon=False)
        plt.xlabel('t [h UTC]')
        plt.ylabel('bias')
        plt.title(titlestr)
        plt.grid()
        plt.savefig('multiscale_bias_s%02d_evo_%s.png' % (s,channel))

#-----------------------------------------------------------------------------------------------------------------------
def overview_plot( xps, rss, colors=None, names=None, figsize=(4,3), title='', file_type='png',
                   reference=None, groups=None, group_colors=None, precip=False,
                   paper=True, show_internal_ids=False, scale_xts=None ) :

    expids = [ xp.expid for xp in xps ]

    if precip :
        from kendapy.precprod_ens import get_precprod_ens, get_fss
        precip_wins = [5, 11, 21] # precip fss windows [grid cells = 6km]
        precip_levs = [0.1,1,5]   # precip rate thresholds [mm/h]
        precip_tresmin = 60 # time resolution for precipitation analysis
        output_times_precip = [60,120,180]

    # sort by experiment type (expid = <experiment day>.<experiment type>)
    xts = {}
    for ixp, xp in enumerate(xps) :
        xt = xp.expid.split('.')[1]
        if not xt in xts :
            xts[xt] = [ixp]
        else :
            xts[xt].append(ixp)
    print('experiment types : ', sorted(xts.keys()) )

    if reference is None :
        xt_ref = sorted(xts.keys())[0]
    else :
        xt_ref = reference
    refname = xt_ref.replace('101','CONV').replace('104','VISCONV')
    xts_nonref = [ xt for xt in sorted(xts.keys()) if xt != xt_ref ]
    print('reference experiment type : ', xt_ref)
    print('non-reference experiment types : ', xts_nonref)

    if not groups is None :
        print('experiment type groups : ')
        for g in groups :
            print('-- ',g,' : ', groups[g], ' -- color ', group_colors[g])

    # compute average experiment type results ..........................................................................

    xtr = {}
    xtfss = {}
    for xt in xts.keys() :
        xtr[xt] = {}
        xtfss[xt] = {}
        n_xp = len(xts[xt])
        print('processing experiment type ', xt, ' with ', n_xp, ' experiments')

        for ixp in xts[xt] :
            print('-- processing experiment',xps[ixp].expid)
            rs = rss[ixp]
            mstat = rs['lfcst_mstat']
            start_times = sorted( [k for k in mstat.keys() if (k.startswith('2') and not k.endswith('050000')) ] )
            output_times = sorted( mstat[start_times[0]].keys() )
            scales = sorted( mstat[start_times[0]][output_times[0]].keys() )
            print( '---- start times        : ', start_times )
            print( '---- output times [min] : ', output_times )
            print( '---- scales             : ', scales )
            mstat_cyc = rs['mstat']
            start_times_cyc = sorted( [k for k in mstat_cyc.keys() if (k.startswith('2') and not k.endswith('050000'))] )

            # get corresponding reference experiment
            expid_ref = xps[ixp].expid.split('.')[0] + '.' + xt_ref
            ixp_ref = -1
            for i, id in enumerate(expids) :
                if id == expid_ref :
                    ixp_ref = i
                    break
            print( '---- reference experiment : ', expid_ref, ixp_ref )
            mstat_ref = rss[ixp_ref]['lfcst_mstat']
            mstat_ref_cyc = rss[ixp_ref]['mstat']

            for s in scales :
                for ot in output_times :
                    if ot <= 60 :
                        ms = mstat_cyc
                        ms_ref = mstat_ref_cyc
                        stimes = start_times_cyc
                    else :
                        ms = mstat
                        ms_ref = mstat_ref
                        stimes = start_times

                    rmse = array( [ ms[t][ot][s]['rmse'] for t in stimes] ).mean()
                    for t in stimes :
                        if not t in ms : print(t, 'missing in ms')
                        if not t in ms_ref : print(t, 'missing in ms_ref')
                    rmse_rel_cases = [ ms[t][ot][s]['rmse']/ms_ref[t][ot][s]['rmse'] for t in stimes]
                    rmse_rel = array(rmse_rel_cases).mean()
                    if not ot in xtr[xt]     : xtr[xt][ot] = {}
                    if not s  in xtr[xt][ot] : xtr[xt][ot][s] = {}
                    if not 'rmse' in xtr[xt][ot][s] :
                        xtr[xt][ot][s]['rmse']     = rmse     / n_xp
                        xtr[xt][ot][s]['rmse_rel'] = rmse_rel / n_xp
                        xtr[xt][ot][s]['rmse_rel_cases'] = rmse_rel_cases
                        #print('creating... ', len(xtr[xt][ot][s]['rmse_rel_cases']))
                    else :
                        xtr[xt][ot][s]['rmse']     += rmse     / n_xp
                        xtr[xt][ot][s]['rmse_rel'] += rmse_rel / n_xp
                        xtr[xt][ot][s]['rmse_rel_cases'] += rmse_rel_cases
                        #print('extending... ', len(xtr[xt][ot][s]['rmse_rel_cases']))
                    #print('---- rmse = ', rmse)

            if precip :
                # compute mean FSS for xtfss[xt][ot]['fss_list'] = list of fss arrays [lev,win]

                for ot in output_times_precip :

                    # compute fss for all start times

                    #if ot <= 60 :
                    #    stimes = start_times_cyc
                    #else :
                    stimes = start_times
                    precip_lfcst = True

                    xp = xps[ixp]
                    f = []
                    for start_time in start_times :
                        fulldate = '2016{}{:02d}0000'.format( xp.expid[:4], Time14(start_time).hour() )
                        #print('getting precprod ensemble for fcst started at {}, time window {} -- {} min'.format( fulldate, ot-precip_tresmin, ot ))


                        cachefpath = xp.settings['PLOT_DIR'] + '/cache/precprod_fss/'
                        if not os.path.exists(cachefpath) :
                            os.system('mkdir -p '+cachefpath)
                        levwinstr = (''.join([ 'l'+str(p) for p in precip_levs ])) + '_' + (''.join([ 'w'+str(p) for p in precip_wins ]))
                        cachefname = 'PPFSS1.0_%s_%d_%d_%s_%s.pickle' % (fulldate,ot,precip_tresmin,'L' if precip_lfcst else 'C',levwinstr)
                        cachefname_full = cachefpath+cachefname

                        if os.path.exists(cachefname_full) :
                            print('reading cache file {}...'.format(cachefname_full))
                            with open(cachefname_full,'r') as fh :
                                f.append( pickle.load(fh))
                        else :
                            pp = get_precprod_ens( xp, fulldate, ot-precip_tresmin, tresmin=precip_tresmin, lfcst=precip_lfcst )
                            fss_ = get_fss( pp, precip_levs, precip_wins, member=-1, target=True ) # FSS for full ensemble
                            f.append( fss_ )

                            print('writing cache file {}...'.format(cachefname_full))
                            with open( cachefname_full,'w') as fh :
                                pickle.dump( fss_, fh, pickle.HIGHEST_PROTOCOL )

                    # save to structure
                    if not ot in xtfss[xt] : xtfss[xt][ot] = {}
                    if 'fss_list' in xtfss[xt][ot] :
                        xtfss[xt][ot]['fss_list'] += f
                    else :
                        xtfss[xt][ot]['fss_list'] = f

                    print(xt, ot, [ e['fss'][1,1] for e in xtfss[xt][ot]['fss_list']])
                    #mean_fss = [ fss[id][h][t]['fss'][l,w] for t in minutes ]
                    #print('----------------')

                    #sys.exit(-1)


        # compute rmse std deviation
        for s in scales :
            for ot in output_times :
                rmse_rel_cases = array( xtr[xt][ot][s]['rmse_rel_cases'] )
                xtr[xt][ot][s]['rmse_rel_std'] = rmse_rel_cases.std()
                #print('---- s={}km, t={}min : rmse_rel stddev computed from {} cases = {}'.format( s*6, ot,
                #                                        rmse_rel_cases.size, xtr[xt][ot][s]['rmse_rel_std']))

    if precip :
        # compute mean FSS deviations from reference run
        for xt in xts :
            for ot in output_times_precip :
                n = len(xtfss[xt][ot]['fss_list'])
                delta_fss = zeros((len(precip_levs),len(precip_wins),n))
                for i in range(n) :
                    delta_fss[:,:,i] = xtfss[xt][ot]['fss_list'][i]['fss'] - xtfss[xt_ref][ot]['fss_list'][i]['fss']
                xtfss[xt][ot]['delta_fss_mean'] = delta_fss.mean(axis=2)
                xtfss[xt][ot]['delta_fss_std'] = delta_fss.std(axis=2)
                print('DFSS ', xt, ot, xtfss[xt][ot]['delta_fss_mean'] )



    # generate plots ...................................................................................................



    # normalized rmse for all cases -> they are correlated...  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    s = 4
    for ot in [0,15,180] :
        fig, ax = plt.subplots(figsize=figsize)
        for xt in xts_nonref :
            ax.plot( xtr[xt][ot][s]['rmse_rel_cases'] )
        fig.savefig('rmse_rel_cases_s{}km_ot{}min.{}'.format(s*6,ot,file_type), bbox_inches='tight')
        plt.close(fig)

    for s in [1,2,4,8,16] :
        s_km = s * 6

        # absolute reflectance RMSE 1h, 2h, 3h vs 15min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        fig, ax = plt.subplots(figsize=figsize)
        #ax.scatter( [ xtr[xt][15][s]['rmse'] for xt in xts ], [ xtr[xt][180][s]['rmse'] for xt in xts ]  )
        for xt in xts :
            ax.text( xtr[xt][15][s]['rmse'], xtr[xt][180][s]['rmse'], xt, fontsize=8 )
        if not groups is None :
            for g in groups :
                #print('marking group ',g)
                if len(groups[g]) > 1 :
                    ax.plot( [ xtr[xt][15][s]['rmse'] for xt in groups[g] ], [ xtr[xt][180][s]['rmse'] for xt in groups[g] ],
                             color=group_colors[g] )
        ax.set_xlim((0.07,0.17))
        ax.set_ylim((0.07,0.17))
        ax.set_xlabel('RMSE 15min')
        ax.set_ylabel('RMSE 3h')
        fig.savefig('e3h_vs_e15min_s{}km.{}'.format(s_km,file_type), bbox_inches='tight')
        plt.close(fig)

        # normalized reflectance RMSE @ 1h, 2h, 3h   vs.  RMSE @ 0min, 15min  . . . . . . . . . . . . . . . . . . . . .
        if xt_ref == '101' :
            plot_std = False
            separate_otplots = False
            add_group_name = False
            connect_group = False
            dotsize = 30
            dotfontsize=9
        else :
            plot_std = True
            separate_otplots = True
            add_group_name = True
            connect_group = True
            #dotsize=100
            #dotfontsize=9
            # for figsize 4,3 :
            dotsize=80
            dotfontsize=8

        for ot0 in [0,15] :
            if not separate_otplots :
                fig, ax = plt.subplots(figsize=figsize)
            #ot_colors = { 60:'#cc00cc', 120:'#cc6600', 180:'r' }
            #ot_colors = { 60:'#000000', 120:'#555555', 180:'#999999' }
            ot_colors = { 60:'k', 120:'k', 180:'k' }
            ot_markers = { 60:'o', 120:'D', 180:'v' }
            for ot in [60,120,180] :
                lbl_ot = True
                if separate_otplots :
                    fig, ax = plt.subplots(figsize=figsize)

                # dots
                if not paper :
                    ax.scatter( [ xtr[xt][ot0][s]['rmse_rel'] for xt in xts],
                                [ xtr[xt][ot ][s]['rmse_rel'] for xt in xts], c='k', edgecolors='none' )
                    # reference type name
                    ax.text( xtr[xt_ref][ot0][s]['rmse_rel'], xtr[xt_ref][ot][s]['rmse_rel'], xt_ref, fontsize=8 )

                # type names and error bars
                for xt in xts_nonref :
                    if not paper :
                        ax.text( xtr[xt][ot0][s]['rmse_rel'], xtr[xt][ot][s]['rmse_rel'], xt, fontsize=8 )
                    if plot_std :
                        ax.plot( xtr[xt][ot0][s]['rmse_rel']+array([-0.5,0.5])*xtr[xt][ot0][s]['rmse_rel_std'], [xtr[xt][ot][s]['rmse_rel']]*2, color='k', linewidth=0.5, zorder=0 )
                        ax.plot( [xtr[xt][ot0][s]['rmse_rel']]*2, xtr[xt][ot][s]['rmse_rel']+array([-0.5,0.5])*xtr[xt][ot][s]['rmse_rel_std'],  color='k', linewidth=0.5, zorder=0 )
                # groups
                #if not groups is None :
                #    for g in groups :
                #        ax.plot( [ xtr[xt][ot0][s]['rmse_rel'] for xt in groups[g] ],
                #                 [ xtr[xt][ot][s]['rmse_rel'] for xt in groups[g] ], color=group_colors[g] )
                #        xt0 = groups[g][0]
                #        ax.text( xtr[xt0][ot0][s]['rmse_rel'], xtr[xt0][ot][s]['rmse_rel'], g, color=group_colors[g] )

                if not groups is None :
                    for ig, g in enumerate(groups) :
                        print('marking group ',g,' = ', groups[g], group_colors[g])
                        if len(groups[g]) > 1 and connect_group :
                            ax.plot( [ xtr[xt][ot0][s]['rmse_rel'] for xt in groups[g] ],
                                     [ xtr[xt][ot ][s]['rmse_rel'] for xt in groups[g] ],
                                     color=group_colors[g], linewidth=2, zorder=2*(ig+1) )
                            if xtr[groups[g][1]][ot0][s]['rmse_rel'] > xtr[groups[g][0]][ot0][s]['rmse_rel'] :
                                ha = 'right'
                            else :
                                ha = 'left'
                        else :
                            ha = 'right'

                        xt0 = groups[g][0]
                        if add_group_name :
                            ax.text( xtr[xt0][ot0][s]['rmse_rel'], xtr[xt0][ot][s]['rmse_rel'], '   '+g+'   ', ha=ha, color=group_colors[g], weight='bold', zorder=2*(ig+1) )
                        if paper :
                            xts_group = groups[g]
                            ax.scatter( [xtr[xt][ot0][s]['rmse_rel'] for xt in xts_group],
                                        [xtr[xt][ot ][s]['rmse_rel'] for xt in xts_group],
                                        c=group_colors[g] if separate_otplots else ot_colors[ot],
                                        label='{:.0f}h'.format(ot/60.0) if (lbl_ot and not separate_otplots) else None,
                                        marker=None if separate_otplots else ot_markers[ot],
                                        edgecolors='none', s=dotsize, zorder=2*(ig+1) )
                            lbl_ot = False
                            if separate_otplots :
                                for ixt, xt in enumerate(xts_group) :
                                    ax.text( xtr[xt][ot0][s]['rmse_rel'], xtr[xt][ot][s]['rmse_rel'], str(ixt+1),
                                             fontsize=dotfontsize, color='w', ha='center', va='center', weight='bold', zorder=2*(ig+1)+1 )

                if separate_otplots :
                    ax.set_xlabel(r'RMSE/RMSE$_{\rm %s}$ @ %dmin'%(refname,ot0))
                    ax.set_ylabel(r'RMSE/RMSE$_{\rm %s}$ @ %dmin'%(refname,ot))
                    #ax.grid()

                    if paper :
                        ax.set_ylim((0.92,1.10))

                    ax.axhline( y=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )
                    ax.axvline( x=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )
                    fig.savefig('erel{}min_vs_erel{}min_s{}km{}.{}'.format(ot,ot0,s_km,'_std' if plot_std else '',file_type), bbox_inches='tight')
                    plt.close(fig)

            if not separate_otplots :
                #ax.set_xlim((0.5,0.75))
                #ax.set_ylim((0.65,1.0))
                ax.set_xlabel(r'RMSE/RMSE$_{\rm %s}$ @ %dmin'%(refname,ot0))
                ax.set_ylabel(r'RMSE/RMSE$_{\rm %s}$ @ 1h, 2h, 3h'%refname)
                ax.set_ylim(top=1.0)
                ax.legend(loc='lower right', fontsize=10) #,frameon=False)
                #ax.grid()
                #ax.axhline( y=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )
                #ax.axvline( x=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )
                fig.savefig('erel123h_vs_erel{}min_s{}km{}.{}'.format(ot0,s_km,'_std' if plot_std else '',file_type), bbox_inches='tight')
                plt.close(fig)

        # 3h RMSE_rel vs d/dt RMSE_rel  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        ot = 180
        ot1 = 150
        fig, ax = plt.subplots(figsize=figsize)
        for xt in xts_nonref :
            ax.text(           xtr[xt][ot][s]['rmse_rel'],                         xtr[xt][ot][s]['rmse_rel']-xtr[xt][ot1][s]['rmse_rel'], xt, fontsize=8 )
        if not groups is None :
            for g in groups :
                print('marking group ',g)
                ax.plot( [ xtr[xt][ot][s]['rmse_rel'] for xt in groups[g] ], [ xtr[xt][ot][s]['rmse_rel']-xtr[xt][ot1][s]['rmse_rel'] for xt in groups[g] ], color=group_colors[g] )
                xt0 = groups[g][0]
                ax.text( xtr[xt0][ot][s]['rmse_rel'], xtr[xt0][ot][s]['rmse_rel']-xtr[xt0][ot1][s]['rmse_rel'], g, color=group_colors[g] )

        ax.axhline( y=0, linestyle=':', color='k', linewidth=0.5, zorder=0 )
        ax.axvline( x=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )

        ax.set_xlabel(r'RMSE/RMSE$_{\rm %s}$ %dmin'%(refname,ot))
        ax.set_ylabel(r'RMSE/RMSE$_{\rm %s}$(%dmin) - RMSE/RMSE$_{\rm %s}$(%dmin)'%(refname,ot,refname,ot1))
        #ax.grid()
        fig.savefig('erel3h_vs_dereldt_s{}km.{}'.format(s_km,file_type), bbox_inches='tight')
        plt.close(fig)

    if not scale_xts is None :
        print('*'*80)
        print('xts_nonref = ', xts_nonref)
        print('scale_xts  = ', scale_xts)
        print(type(scale_xts[0]))
        print(type(xts_nonref[0]))

        # scale-dependency of RMSE_rel  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        scales_ = scales[:-1]
        skm = array([s*6 for s in scales_])
        for ot in [60,120,180] :
            fig, ax = plt.subplots(figsize=figsize)
            for xt in xts_nonref :
                plot_it = True
                if not scale_xts is None :
                    if not xt in scale_xts :
                        print('xt=', xt, ' is not in ', scale_xts )
                        plot_it = False
                if plot_it :
                    c = 'k'
                    group=''
                    group_idx = 0
                    for g in groups :
                        if xt in groups[g] :
                            c = group_colors[g]
                            group = g
                            for ig in range(len(groups[g])) :
                                if xt ==  groups[g][ig] :
                                    group_idx = ig+1
                                    break
                            break
                    rmse_rel     = array([ xtr[xt][ot][s]['rmse_rel'    ] for s in scales_ ])
                    rmse_rel_std = array([ xtr[xt][ot][s]['rmse_rel_std'] for s in scales_ ])
                    ax.fill_between( skm, rmse_rel-rmse_rel_std/2, rmse_rel+rmse_rel_std/2, facecolor=c, edgecolor='none', alpha=0.2, zorder=10 )
                    ax.plot( skm, rmse_rel, color=c, zorder=20 )
                    if show_internal_ids :
                        lbl = ' {}-{} [{}]'.format(group, group_idx, xt)
                    else :
                        lbl = ' {}-{}'.format(group, group_idx)
                    ax.text( skm.max(), rmse_rel[-1], lbl, ha='left', va='center',
                             color=c, fontsize=8, weight='bold', zorder=20)
            ax.set_xticks(skm)
            ax.set_xlim((0,220))
            ax.plot( (0,220), (1,1), ':k', linewidth=0.5, zorder=30 )
            ax.set_ylabel(r'RMSE / RMSE$_{\rm %s}$ @ %dmin'%(refname,ot))
            ax.set_xlabel('scale [km]')
            fig.savefig('erel{}min_vs_scale.{}'.format(ot,file_type), bbox_inches='tight')


    # mean FSS-FSS_ref vs. analysis RMSE_rel  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    for ot_refl in [0,15] :
        for ot_precip in [60,120,180] :
            s=4
            fig, ax = plt.subplots(figsize=figsize)
            if not paper :
                ax.scatter( [xtr[xt][ot_refl][s]['rmse_rel'] for xt in xts_nonref],
                            [xtfss[xt][ot_precip]['delta_fss_mean'][1,1] for xt in xts_nonref], c='k', edgecolors='none' )

            for xt in xts_nonref :
                # error bars
                ax.plot( xtr[xt][ot_refl][s]['rmse_rel'] + array([-0.5,0.5])*xtr[xt][ot_refl][s]['rmse_rel_std'],
                         xtfss[xt][ot_precip]['delta_fss_mean'][1,1]*array([1,1]), 'k', linewidth=0.5, zorder=0 )
                ax.plot( xtr[xt][ot_refl][s]['rmse_rel']*array([1,1]),
                         xtfss[xt][ot_precip]['delta_fss_mean'][1,1] + array([-0.5,0.5])*xtfss[xt][ot_precip]['delta_fss_std'][1,1], 'k', linewidth=0.5, zorder=0 )
                # label
                if not paper :
                    ax.text(           xtr[xt][ot_refl][s]['rmse_rel'], xtfss[xt][ot_precip]['delta_fss_mean'][1,1], xt, fontsize=8, ha='left', va='bottom' )

            if not groups is None :
                for ig, g in enumerate(groups) :
                    print('marking group ',g,' = ', groups[g], group_colors[g])
                    xt0 = groups[g][0]
                    if len(groups[g]) > 1 :
                        ax.plot( [ xtr[xt ][ot_refl][s]['rmse_rel'] for xt in groups[g] ],
                                 [ xtfss[xt ][ot_precip]['delta_fss_mean'][1,1] for xt in groups[g] ],
                                 color=group_colors[g], linewidth=2, zorder=2*(ig+1) )
                        if xtr[groups[g][1]][ot_refl][s]['rmse_rel'] > xtr[groups[g][0]][ot_refl][s]['rmse_rel'] :
                            ha = 'right'
                        else :
                            ha = 'left'
                    else :
                        ha = 'right'
                    ax.text( xtr[xt0][ot_refl][s]['rmse_rel'], xtfss[xt0][ot_precip]['delta_fss_mean'][1,1], '   '+g+'   ', ha=ha, color=group_colors[g], weight='bold', zorder=2*(ig+1) )
                    if paper :
                        xts_group = groups[g]
                        ax.scatter( [xtr[xt][ot_refl][s]['rmse_rel'] for xt in xts_group],
                                    [xtfss[xt][ot_precip]['delta_fss_mean'][1,1] for xt in xts_group], c=group_colors[g], edgecolors='none', s=dotsize, zorder=2*(ig+1) )
                        for ixt, xt in enumerate(xts_group) :
                            ax.text( xtr[xt][ot_refl][s]['rmse_rel'], xtfss[xt][ot_precip]['delta_fss_mean'][1,1], str(ixt+1),
                                     fontsize=dotfontsize, color='w', ha='center', va='center', weight='bold', zorder=2*(ig+1)+1 )

            ax.axhline( y=0, linestyle=':', color='k', linewidth=0.5, zorder=0 )
            ax.axvline( x=1, linestyle=':', color='k', linewidth=0.5, zorder=0 )

            if paper :
                ax.set_ylim((-0.03,0.04))

            ax.set_xlabel(r'RMSE/RMSE$_{\rm %s}$ %dmin'%(refname,ot_refl))
            ax.set_ylabel(r'precip. FSS-FSS$_{\rm %s}$, t=%dmin'%(refname,ot_precip))
            #ax.grid()
            fig.savefig('dFSSprecip_l1w11_{}min_vs_erel{}min_s{}km.{}'.format(ot_precip,ot_refl,s*6,file_type), bbox_inches='tight')
            plt.close(fig)


    # generate table  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if not groups is None :
        s=4
        if paper :
            print()
            print('% LATEX EXPERIMENT TYPE TABLE --------------------------------------------------------------------')

            # define the group colors in latex code
            for g in groups :
                c = group_colors[g]
                if c.startswith('#') :
                    rf, gf, bf = matplotlib.colors.hex2color(c)
                else :
                    rf, gf, bf, af = matplotlib.colors.to_rgba(c)
                print("\\definecolor{col%s}{rgb}{%.2f,%.2f,%.2f}"%(g,rf,gf,bf))
            # table header
            print("\\begin{table}[]")
            print("\\centering")
            print("\\begin{tabular}{c|cccccc}")
            print("ID & $T_{\\rm vis}$ & $\sigma_o$ & $l_h$ & $l_{so}$ & $l_{th}$ & $N^{\\rm sat}_{\\rm gp}$ & $N^{\\rm sat}_{\\rm tot}$ \\\\")
            print("   & [min]          &            & [km]  & [km]     & [km]     &                          &  [$10^3/$h] \\\\")

            for g in groups :
                print("\\hline")
                for ixt, xt in enumerate(groups[g]) :
                    # identify eperiment matching experiment type (day does not matter here)
                    ixp = xts[xt][0]
                    xp = xps[ixp]
                    id = g+'-'+str(ixt+1) + ' (='+xp.expid.split('.')[1]+')'
                    idcol = "\\textcolor{col%s}{\\bf %s}"%(g,id)

                    Tvis = str(int(xp.settings['VISOP_ASSIM_INTERVAL']))
                    e_o = '{:.2f}'.format(float(xp.settings['VISOP_ERROR'].replace('nocc,','').split(',')[0]))

                    lh  = '{:.0f}'.format( float(xp.settings['VISOP_HLOC']) )

                    lso_ = int(xp.settings['VISOP_SUPEROBB'].split(',')[0])*3
                    if lso_ == 3 :
                        lso = '--'
                    else :
                        lso = str(lso_)
                    lth_ = xp.settings['VISOP_THINNING']
                    if lth_ == '1' :
                        lth = '--'
                    else :
                        lth = str( lso_ * int(lth_.split(',')[0]) )

                    l_obs = int(xp.settings['VISOP_SUPEROBB'].split(',')[0])*3 * float(xp.settings['VISOP_THINNING'].split(',')[0])
                    d = '{:.1f}'.format((2*pi*float(xp.settings['VISOP_HLOC'])**2) * (60.0/int(xp.settings['VISOP_ASSIM_INTERVAL'])) / (l_obs*l_obs))

                    n_sat_hour = 4628*((36/l_obs)**2)*(60.0/int(xp.settings['VISOP_ASSIM_INTERVAL']))

                    if g in ['S18','S18T2','S36','T18'] :
                        e_o = '{\\bf %s}'%e_o
                    if g == 'HL' :
                        lh = '{\\bf %s}'%lh
                        d  = '{\\bf %s}'%d
                    if g == 'TDENS' :
                        Tvis = '{\\bf %s}'%Tvis
                        lh = '{\\bf %s}'%lh

                    print( "{} & {} & {} & {} & {} & {} & {} & {:.1f}\\\\".format( idcol, Tvis, e_o, lh, lso, lth, d, n_sat_hour/1e3 ) )
            print("\\end{tabular}")
            print("\\caption{Assimilation settings overview.}")
            print("\\label{tab:xtypes}")
            print("\\end{table}")
            print()

        else :
            print('-'*80)
            for xt in xts :
                grps = ''
                for g in groups :
                    if xt in groups[g] :
                        grps += g+' '

                ixp = xts[xt][0]
                print( xps[ixp].description( template='_VIS_ e0={:3.0f} e1={:3.0f} e3={:3.0f} {}'.format(
                    xtr[xt][0][s]['rmse']*1e3, xtr[xt][60][s]['rmse']*1e3, xtr[xt][180][s]['rmse']*1e3, grps ) ))
            print('-'*80)


#-----------------------------------------------------------------------------------------------------------------------
def multiscale_comparison_plot( xps, rss, cycle=True, lfcst=True, spread=True, colors=None, names=None, xrange=None, yrange=None,
                                figsize=(10,5), title='', show_expid=False, file_type='png' ) :

    times_set = set()
    for rs in rss :
        for t in rs['times'] : times_set.add(t)
    times = sorted(list(times_set))
    #times  = rss[0]['times']

    scales = rss[0]['mstat']['scales']
    print(('times ', times))
    print(('scales ', scales))

    hmin = Time14(times[0]).dayhour()
    hmax = hmin

    if cycle and not lfcst :
        alpha_cycle = 1
        lw_cycle = 2
    else :
        alpha_cycle = 0.5
        lw_cycle = 1

    # individual error/bias evolution plot for each scale

    for iscl, s in enumerate(scales) :
        km = s*6

        # create new plot
        #fig, ax = plt.subplots()
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(1, 1, 1)  # specify (nrows, ncols, axnum)


        #for i,l in enumerate(xps.keys()) :
        #    if not names is None :
        #        expname = names[i]
        #    else :
        #        expname = xps[l].settings['EXPID']
        #    xp = xps[l]
        #    rs = rss[l]
        for i in range(len(xps)) :
            if not names is None :
                if show_expid :
                    expname = xps[i].settings['EXPID'] + ': ' + names[i]
                else :
                    expname = names[i]
            else :
                expname = xps[i].settings['EXPID']
            xp = xps[i]
            rs = rss[i]
            mstat = rs['mstat']
            if 'lfcst_mstat' in  rs :
                lfcst_mstat = rs['lfcst_mstat']
            else :
                lfcst_mstat = None
            if colors is None :
                col = colseq(i,len(xps))
            else :
                col = colors[i]

            add_label=True
            h = hmin
            for i, t in enumerate(times) :

                if lfcst and not lfcst_mstat is None :
                    if t in lfcst_mstat :
                        lfcst_t_min = sorted(lfcst_mstat[t].keys())
                        lfcst_t_hour = Time14(t).dayhour() + array(lfcst_t_min)/60.0
                        ax.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['rmse'] for f in lfcst_t_min ], color=col, linewidth=2,
                                 label=expname if add_label else None )
                        add_label=False
                        ax.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['bias'] for f in lfcst_t_min ], color=col, linewidth=1 )
                        if spread :
                            ax.plot( lfcst_t_hour, [ lfcst_mstat[t][f][s]['spread'] for f in lfcst_t_min ], ':', color=col, linewidth=1 )

                if cycle :
                    if t in mstat :
                        if len(xp.visop_fcsttimes()) == len(list(mstat[t].keys())) :
                            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['rmse'] for f in sorted(mstat[t].keys()) ],
                                      color=col, linewidth=lw_cycle, alpha=alpha_cycle, label=expname if add_label else None )
                            add_label = False
                            plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['bias'] for f in sorted(mstat[t].keys()) ],
                                      color=col, linewidth=1, alpha=alpha_cycle )
                            if spread :
                                plt.plot( h+xp.visop_fcsttimes()/60.0, [ mstat[t][f][s]['spread'] for f in sorted(mstat[t].keys()) ], ':',
                                      color=col, linewidth=1, alpha=alpha_cycle )
                        else :
                            print(('multiscale_comparison_plot : data is missing in mstat[', t, ']'))

                #add_label=False
                #h += float(xp.settings['ASSINT'])/3600.0
                if i < len(times)-1 :
                    h += (Time14(times[i+1])-Time14(times[i])).dayhour()
            hmax = maximum( h, hmax )

        if xrange is None :
            xmin = hmin-1
            xmax = hmax+2
        else :
            xmin, xmax = xrange
        ax.plot(   ( xmin, xmax ), (0,0), '--', color='#999999', linewidth=1, zorder=0 )
        ax.set_xlim( xmin, xmax )

        if not yrange is  None :
            ax.set_ylim( yrange[0], yrange[1] )
        else :
            ax.set_ylim( -0.05, 0.22 )

        ax.legend(loc='upper center', frameon=False) #, fontsize=10) #center right 'upper center'
        ax.set_xlabel('t [h UTC]')
        ax.set_ylabel('ens. mean rmse, bias' +(', spread' if spread else ''))
        ax.set_title(title)
        xl, xr = ax.get_xlim()
        yl, yh = ax.get_ylim()
        #ax.text( xl + 0.01*(xr-xl), yh-0.01*(yh-yl), "reflectance, scale=%dkm"%km, ha='left', va='top' )
        ax.text( xl + 0.01*(xr-xl), yl+0.01*(yh-yl), "reflectance, scale=%dkm"%km, ha='left', va='bottom' )
        #ax.grid()
        fig.savefig('multiscale_rmse_comparison_s%02d_evo_%s%s.%s' % (s, 'withcycle_' if cycle else '', channel,
                                                                      file_type), bbox_inches='tight')

#-----------------------------------------------------------------------------------------------------------------------
def fss_comparison_plot( xps, rss, cycle=True, colors=None, names=None, xrange=None, yrange=None,
                         figsize=(6,4), title='', show_expid=True, file_type='png' ) :

    times_set = set()
    for rs in rss :
        for t in rs['times'] : times_set.add(t)
    times = sorted(list(times_set))
    output_times = array( sorted(list(rss[0]['stats'][times[0]].keys())) )
    lfcst_output_times = None
    for t in times :
        if t in rss[0]['lfcst_stats'] :
            t0 = t
            lfcst_output_times = array( sorted(list(rss[0]['lfcst_stats'][t].keys())) )
            break
    if lfcst_output_times is None :
        lfcst = False
    else :
        lfcst = True
        print('lfcst output times [min] : ', lfcst_output_times)
    print('      output times [min] : ', output_times)

    fss_thresholds = []
    for f in rss[0]['stats'][t0][output_times[0]].keys() :
        if f.startswith('fss') :
            fss_thresholds.append(f)
    print('fss thresholds : ', fss_thresholds)

    fss_windows = rss[0]['stats'][t0][output_times[0]]['fss0.50']['windows']
    print('fss windows : ', fss_windows)

    print( rss[0].keys() ) # ['stats', 'scales', 'lfcst_clc', 'refl_thresholds', 'fss_windows', 'clc', 'lfcst_stats', 'mstat', 'times', 'lfcst_mstat']
    print( rss[0]['stats'][times[0]][output_times[0]].keys() ) # ['fss0.60', 'rmse', 'fss0.50', 'bias', 'fss0.40', 'spread', 'fss0.25', 'fss0.30', 'fss0.20']
    print( rss[0]['stats'][times[0]][output_times[0]]['fss0.60'].keys() ) # ['num', 'members', 'windows', 'belscl', 'levels', 'fss_random', 'den', 'fss_target', 'fss']
    print( rss[0]['stats'][times[0]][output_times[0]]['fss0.60']['fss'] )
    #sys.exit(-1)

    for fth in fss_thresholds :
        print('fss threshold ', fth[3:])

        # believable scale plot
        fig, ax = plt.subplots(figsize=figsize)
        for ixp, rs in enumerate(rss) :
            label = True
            print('processing experiment '+xps[ixp].expid)
            for t in times :
                if lfcst :
                    if 'lfcst_stats' in rs and t in rs['lfcst_stats'] :
                        belscl = array([ rs['lfcst_stats'][t][t_output][fth]['belscl'][0] for t_output in lfcst_output_times ])
                        belscl[where(belscl < 1)] = NaN
                        ax.plot( (Time14(t).daymin() + lfcst_output_times)/60.0, belscl,
                                 color=colors[ixp % len(colors)], linewidth=2,
                                 label=names[ixp] if label else None )
                        label = False
                    else :
                        print('time {} is missing'.format(t))

                if cycle :
                    if t in rs['stats'] :
                        belscl = array([ rs['stats'][t][t_output][fth]['belscl'][0] for t_output in output_times ])
                        belscl[where(belscl < 1)] = NaN
                        ax.plot( (Time14(t).daymin() + output_times)/60.0, belscl,
                                 color=colors[ixp % len(colors)], linewidth = 0.5 if lfcst else 2,
                                 label=names[ixp] if label else None )
                        label = False
                    else :
                        print('time {} is missing'.format(t))

        ax.legend(frameon=False,loc='upper left')
        ax.set_xlabel('t [h UTC]')
        ax.set_ylabel('believable scale [km] for R>'+fth[3:])
        fig.savefig('refl_'+fth+'_belscl.'+file_type, bbox_inches='tight')
        plt.close(fig)

        # fss plot
        for iwin, win in enumerate(fss_windows) :
            fig, ax = plt.subplots(figsize=figsize)
            for ixp, rs in enumerate(rss) :
                label = True
                print('processing experiment '+xps[ixp].expid)
                for t in times :
                    if lfcst :
                        if 'lfcst_stats' in rs and t in rs['lfcst_stats'] :
                            print(iwin, win, ' -> FSS_RANDOM = ', rs['lfcst_stats'][t][t_output][fth]['fss_random'])
                            fss = array([ rs['lfcst_stats'][t][t_output][fth]['fss'][0][iwin] for t_output in lfcst_output_times ])
                            t_hours = (Time14(t).daymin() + lfcst_output_times)/60.0
                            ax.plot( t_hours, fss,
                                     color=colors[ixp % len(colors)], linewidth=2,
                                     label=names[ixp] if label else None )
                            label = False

                            # add random and target FSS
                            if ixp == 0 :
                                fss_random = array([ rs['lfcst_stats'][t][t_output][fth]['fss_random'][0] for t_output in lfcst_output_times ])
                                fss_target = array([ rs['lfcst_stats'][t][t_output][fth]['fss_target'][0] for t_output in lfcst_output_times ])
                                ax.plot( t_hours, fss_random, ':', color='#999999')
                                ax.plot( t_hours, fss_target, '--', color='#999999')
                        else :
                            print('time {} is missing'.format(t))

                    if cycle :
                        if t in rs['stats'] :
                            fss = array([ rs['stats'][t][t_output][fth]['fss'][0][iwin] for t_output in output_times ])
                            ax.plot( (Time14(t).daymin() + output_times)/60.0, fss,
                                     color=colors[ixp % len(colors)], linewidth = 0.5 if lfcst else 2,
                                     label=names[ixp] if label else None )
                            label = False
                        else :
                            print('time {} is missing'.format(t))

            ax.set_ylim((0,1))
            ax.legend(frameon=False,loc='upper left')
            ax.set_xlabel('t [h UTC]')
            ax.set_ylabel('FSS for R>'+fth[3:]+', '+str(win*6)+'km')
            fig.savefig('refl_'+fth+'_win'+str(win)+'.'+file_type, bbox_inches='tight')
            plt.close(fig)






#-------------------------------------------------------------------------------
if __name__ == "__main__": # ---------------------------------------------------
#-------------------------------------------------------------------------------

    parser = argparse.ArgumentParser(description='Generate VISOP plots for KENDA experiment')

    parser.add_argument( '-E', '--evolution',   dest='error_evolution',   help='generate error evolution plots', action='store_true' )
    parser.add_argument(       '--no-ekf',      dest='no_ekf',            help='do not use ekf data in error evolution plots', action='store_true' )

    parser.add_argument( '-o', '--overview',   dest='overview',   help='generate overview plots', action='store_true' )
    parser.add_argument(       '--reference',  dest='reference',  help='reference experiment type',  default='101' )
    parser.add_argument(       '--groups',     dest='groups',     help='define experiment type groups, e.g. ES18,102,103,104,111,113,129:ES36,105,106,114,104',  default='' )
    parser.add_argument(       '--precip',     dest='precip',     help='add precipitation fss improvements to overview plot', action='store_true' )
    parser.add_argument(       '--scale-xts',  dest='scale_xts',  help='comma-separated list of exp. types to be used for scale plots', default='' )

    parser.add_argument(       '--fss',         dest='fss',  help='plot fss evolution', action='store_true' )

    parser.add_argument( '-c', '--clc',         dest='clc_evolution',  help='plot clc evolution', action='store_true' )
    parser.add_argument( '-n', '--not-all-members',  dest='not_all_members',  help='do not generate plots for each of the members', action='store_true' )
    parser.add_argument( '-m', '--multiscale',   dest='multiscale',        help='multiscale metrics plots', action='store_true' )
    #parser.add_argument(       '--scales',      dest='scales', default='1,2,3,4,5,6,7'

    parser.add_argument( '-C', '--compare',     dest='compare',     help='generate comparison plots with data from all specified experiments',
                                                                    action='store_true' )
    parser.add_argument(       '--no-cycle',    dest='no_cycle',    help='show only results from long forecasts', action='store_true' )
    parser.add_argument(       '--no-spread',   dest='no_spread',   help='do not plot spread', action='store_true' )

    parser.add_argument( '-l', '--lfcst',       dest='lfcst',      help='take also long forecasts (not only cycling results) into account',   action='store_true' )

    parser.add_argument( '-T', '--transform',   dest='transform',  help='transform images to observations',  action='store_true' )
    parser.add_argument(       '--i2o-settings',   dest='i2o_settings',  help='visop_i2o settings string [default: the one from the experiment settings]',  default='experiment' )

    parser.add_argument(       '--channel',     dest='channel',    help='channel[s] (comma-separated list, deafult=VIS006)', default='VIS006' )

    parser.add_argument(       '--style',       dest='style',      help='plot style', default='' )
    parser.add_argument(       '--colors',      dest='colors',     help='comma-separated list of colors for the experiments', default='' )
    parser.add_argument(       '--names',       dest='names',      help='comma-separated list of names (use ,, for commas within the names)', default='' )
    parser.add_argument(       '--title',       dest='title',      help='plot title', default='' )
    parser.add_argument(       '--xrange',      dest='xrange',     type=str, help='xmin,xmax for the RMSE plots', default='' )
    parser.add_argument(       '--yrange',      dest='yrange',     type=str, help='ymin,ymax for the RMSE plots', default='' )
    parser.add_argument(       '--figsize',     dest='figsize',    type=str, help='witdh,height for the RMSE plots', default='' )

    parser.add_argument( '-s', '--start-time',  dest='start_time',  help='start time',    default='' )
    parser.add_argument( '-e', '--end-time',    dest='end_time',    help='end time',      default='' )
    parser.add_argument( '-d', '--delta-time',  dest='delta_time',  help='time interval', default='' )

    parser.add_argument( '-p', '--output-path', dest='output_path', help='path to the directory in which the plots will be saved', default='auto' )
    parser.add_argument( '-I', '--input-path',  dest='input_path',  help='path to the directory containing the log files', default='' )
    parser.add_argument( '-f', '--filetype',    dest='file_type',   help='file type [ png (default) | pdf | eps | svg ...]', default='png' )
    parser.add_argument( '-v', '--verbose',     dest='verbose',     help='be more verbose',   action='store_true' )    

    parser.add_argument(       '--recompute',   dest='recompute',   help='ignore/overwrite cache files', action='store_true' )

    parser.add_argument( 'logfile', metavar='logfile', help='log file name (will be prepended by --input-path, if specified) or experiment id', nargs='*' )
    args = parser.parse_args()

    if args.colors != '' :
        colors = args.colors.split(',')
    else :
        colors = None

    if args.names != '' :
        names = [ n.replace('_COMMA_',',') for n in args.names.replace(',,','_COMMA_').split(',') ]
    else :
        names = None

    if args.yrange != '' :
        yrange = [ float(x) for x in args.yrange.replace('\-','-').split(',') ]
        #yrange = [-0.06,0.16]
    else :
        yrange = None

    if args.xrange != '' :
        xrange = [ float(x) for x in args.xrange.replace('\-','-').split(',') ]
    else :
        xrange = None


    if args.figsize != '' :
        figsize = [ float(x) for x in args.figsize.split(',') ]
    else :
        figsize = None

    # process all log files

    if args.logfile[0].startswith('groups') :
        # get exp ids as combination of the specified days and the experiment types from --groups
        days = args.logfile[0].split(',')[1:]

        ids = []
        for gstr in args.groups.split(':') :
            ids += gstr.split(',')[2:]
        if args.reference not in ids :
            print('Adding reference experiment...')
            ids.append( args.reference )

        logfiles = []
        for day in days :
            logfiles += [day+'.'+i for i in set(ids)]

        print('Experiment ids constructed from group definitions: ', logfiles)
        #sys.exit(-1)
    else :
        logfiles = args.logfile

    for i, lfn in enumerate(logfiles) :
        if not lfn.endswith('.log') : # asssume it is an experiment id and not a log file
            logfiles[i] += '/run_cycle_'+logfiles[i]+'.log'
        if args.input_path != '' : # add input path
            logfiles[i] = os.path.join( args.input_path, logfiles[i] )

    if args.names != '' :
        xpnames = args.names.split(',')
    else :
        xpnames = [ logfile.split('/')[-1].replace('run_cycle_','').replace('.log','.') for logfile in logfiles ]


    xps = {}
    rss = {}
    for ilog, logfile in enumerate(logfiles) :

        print()
        print(("processing file %s ..." % logfile))

        xp = Experiment(logfile)
        xps[logfile] = xp
        print(('experiment %s : %s #members, first fcst start time %s, last analysis time %s' % ( \
               xp.settings['exp'], xp.settings['N_ENS'], xp.fcst_start_times[0], xp.veri_times[-1] )))

        if args.names != '' :
            xpnames[ilog] = xp.description(xpnames[ilog])
            print(('NAME==',xpnames[ilog]))

        titlestr = "%s T_win=%4.2fh e_o=%s h_loc=%s superobb=%s " % (
                    xp.settings['EXPID'],
                    float(xp.settings['ASSINT'])/3600.0,
                    xp.settings['VISOP_ERROR'],
                    xp.settings['VISOP_HLOC'],
                    xp.settings['VISOP_SUPEROBB'])

        # set some default values
        if args.output_path != '' :
            if args.output_path != 'auto' :
                output_path = args.output_path+'/'
            else :
                output_path = xp.settings['PLOT_DIR']+'/visop/'
                if not os.path.exists(output_path) :
                    os.system('mkdir -p '+output_path)
        else :
            output_path = ''

        # determine time range
        if args.start_time != '' :
            start_time = args.start_time
        else :
            for t in xp.veri_times :
                t14 = Time14(t)
                if t14.hour() > int(xp.settings['VISOP_START_HOUR']) and t14.hour() < int(xp.settings['VISOP_STOP_HOUR']) :
                    start_time = t
                    break
                if t14.hour() == int(xp.settings['VISOP_START_HOUR']) :
                    if t14.minute() >= int(xp.settings['VISOP_START_MINUTE']) :
                        start_time = t
                        break
                if t14.hour() == int(xp.settings['VISOP_STOP_HOUR']) :
                    if t14.minute() <= int(xp.settings['VISOP_STOP_MINUTE']) :
                        start_time = t
                        break
        print(('selecting start time = ', start_time))

        if args.end_time != '' :
            end_time = args.end_time
        else :
            end_time = xp.fcst_start_times[-1]
            end_time = end_time[:8] + ("%02d" % (int(xp.settings['VISOP_STOP_HOUR'])-1)) + end_time[10:]
        print(('selecting end time = ', end_time))

        if args.delta_time != '' :
            delta_time = args.delta_time
        else :
            delta_time = xp.settings['ASSINT']
        times = time_range( start_time, end_time, delta_time  )
        print(('fcst start times: ', times))

        # loop over channels and times, read data and generate plots
        for channel in args.channel.split(',') :

            # get data
            rs = get_visop_fcst_stats( xp, times=times, channel=channel, lfcst          =args.lfcst,
                                                                         error_evolution=args.error_evolution,
                                                                         clc_evolution  =args.clc_evolution,
                                                                         multiscale     =args.multiscale,
                                                                         recompute      =args.recompute )
            rss[logfile] = rs

            if not args.compare :
                if args.error_evolution : stats = rs['stats']
                if args.clc_evolution   : clc   = rs['clc']
                if args.multiscale      : mstat = rs['mstat']
                if args.lfcst :
                    if args.error_evolution : lfcst_stats = rs['lfcst_stats']
                    if args.clc_evolution   : lfcst_clc   = rs['lfcst_clc']
                    if args.multiscale      : lfcst_mstat = rs['lfcst_mstat']

                # generate plots

                if args.error_evolution :
                    error_evo_plot( xp, times, stats, lfcst_stats if args.lfcst else None, titlestr=titlestr, style=args.style )

                if args.clc_evolution :
                    clc_evo_plot( xp, times, clc, lfcst_clc if args.lfcst else None, titlestr=titlestr )

                if args.multiscale :
                    multiscale_evo_plot( xp, times, mstat, lfcst_mstat if args.lfcst else None, titlestr=titlestr )

                if args.fss :
                    fss_evo_plot( xp, times, rs, lfcst=args.lfcst, titlestr=titlestr, args=args )

        # end of channel loop ......................................................................
    # end of logfile loop ..........................................................................

    if args.compare :
        print()
        print('>>>>> COMPARING')
        for n in xpnames :
            print(('>>>>> ', n))
        print()
        if args.error_evolution :
            print()
            print('>>>>> error evo comparison')
            for i, l in enumerate(logfiles) : #sorted(rss.keys())) :
                error_evo_plot( xps[l], rss[l]['times'], rss[l]['stats'], rss[l]['lfcst_stats'] if args.lfcst else None,
                                ekf=False,
                                start_plot = True if i == 0 else False,
                                finish_plot = True if i == len(rss)-1 else False,
                                color = colseq(i,len(rss)),
                                name = xpnames[i], #None if names is None else names[i],
                                style=args.style,
                                file_type=args.file_type )
            for i, l in enumerate(logfiles) : #sorted(rss.keys())) :
                print((i, l))

        if args.multiscale :
            print()
            print('>>>>> multiscale error evo comparison')
            multiscale_comparison_plot( [xps[l] for l in logfiles], [rss[l] for l in logfiles],
                                        cycle = not args.no_cycle, lfcst=args.lfcst,
                                        spread = not args.no_spread, colors=colors, names=xpnames, title=args.title,
                                        xrange=xrange, yrange=yrange, figsize=figsize, file_type=args.file_type )
        if args.overview :
            print()
            print('>>>>> visop stats overview')
            if args.groups == '' :
                groups = None
                group_colors = None
            else :
                groups = {}
                group_colors = {}
                gdefs = args.groups.split(':')
                for g in gdefs :
                    t = g.split(',')
                    groups[t[0]] = t[2:]
                    group_colors[t[0]] = t[1]

            overview_plot( [xps[l] for l in logfiles], [rss[l] for l in logfiles], colors=colors, names=xpnames,
                           title=args.title, figsize=figsize, file_type=args.file_type,
                           reference=args.reference if args.reference!='' else None,
                           groups=groups, group_colors=group_colors, precip=args.precip,
                           scale_xts=args.scale_xts.split(',') if args.scale_xts != '' else None )

        if args.fss :
            print()
            print('>>>>> reflectance fss plots')
            fss_comparison_plot( [xps[l] for l in logfiles], [rss[l] for l in logfiles], cycle = not args.no_cycle,
                                 colors=colors, names=xpnames, title=args.title,
                                 xrange=xrange, yrange=yrange, figsize=figsize, file_type=args.file_type )
